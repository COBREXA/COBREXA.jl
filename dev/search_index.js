var documenterSearchIndex = {"docs":
[{"location":"examples/02a-optimizer-parameters/","page":"Changing optimizer parameters","title":"Changing optimizer parameters","text":"EditURL = \"02a-optimizer-parameters.jl\"","category":"page"},{"location":"examples/02a-optimizer-parameters/#Changing-optimizer-parameters","page":"Changing optimizer parameters","title":"Changing optimizer parameters","text":"","category":"section"},{"location":"examples/02a-optimizer-parameters/","page":"Changing optimizer parameters","title":"Changing optimizer parameters","text":"Many optimizers require fine-tuning to produce best results. You can pass in additional optimizer settings via the settings parameter of flux_balance_analysis. These include e.g.","category":"page"},{"location":"examples/02a-optimizer-parameters/","page":"Changing optimizer parameters","title":"Changing optimizer parameters","text":"set_optimizer_attribute (typically allowing you to tune e.g. iteration limits, tolerances, or floating-point precision)\nset_objective_sense (allowing you to change and reverse the optimization direction, if required)\nsilence to disable the debug output of the optimizer\nand even set_optimizer, which changes the optimizer implementation used (this is not quite useful in this case, but becomes beneficial with more complex, multi-stage optimization problems)","category":"page"},{"location":"examples/02a-optimizer-parameters/","page":"Changing optimizer parameters","title":"Changing optimizer parameters","text":"To demonstrate this, we'll use the usual toy model:","category":"page"},{"location":"examples/02a-optimizer-parameters/","page":"Changing optimizer parameters","title":"Changing optimizer parameters","text":"using COBREXA\nimport JSONFBCModels, Tulip\n\ndownload_model(\n    \"http://bigg.ucsd.edu/static/models/e_coli_core.json\",\n    \"e_coli_core.json\",\n    \"7bedec10576cfe935b19218dc881f3fb14f890a1871448fc19a9b4ee15b448d8\",\n)\n\nmodel = load_model(\"e_coli_core.json\")","category":"page"},{"location":"examples/02a-optimizer-parameters/","page":"Changing optimizer parameters","title":"Changing optimizer parameters","text":"Running a FBA with a silent optimizer that has slightly increased iteration limit for IPM algorithm may now look as follows:","category":"page"},{"location":"examples/02a-optimizer-parameters/","page":"Changing optimizer parameters","title":"Changing optimizer parameters","text":"solution = flux_balance_analysis(\n    model,\n    Tulip.Optimizer;\n    settings = [silence, set_optimizer_attribute(\"IPM_IterationsLimit\", 1000)],\n)","category":"page"},{"location":"examples/02a-optimizer-parameters/","page":"Changing optimizer parameters","title":"Changing optimizer parameters","text":"To see some of the effects of the configuration changes, you may e.g. deliberately cripple the optimizer's possibilities to a few iterations, which will cause it to fail, return no solution, and verbosely describe what happened:","category":"page"},{"location":"examples/02a-optimizer-parameters/","page":"Changing optimizer parameters","title":"Changing optimizer parameters","text":"solution = flux_balance_analysis(\n    model,\n    Tulip.Optimizer;\n    settings = [set_optimizer_attribute(\"IPM_IterationsLimit\", 2)],\n)\n\nprintln(solution)","category":"page"},{"location":"examples/02a-optimizer-parameters/","page":"Changing optimizer parameters","title":"Changing optimizer parameters","text":"Applicable optimizer attributes are documented in the documentations of the respective optimizers. To browse the possibilities, you may want to see the JuMP documentation page that summarizes the references to the available optimizers.","category":"page"},{"location":"examples/02a-optimizer-parameters/","page":"Changing optimizer parameters","title":"Changing optimizer parameters","text":"","category":"page"},{"location":"examples/02a-optimizer-parameters/","page":"Changing optimizer parameters","title":"Changing optimizer parameters","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"EditURL = \"03-parsimonious-flux-balance.jl\"","category":"page"},{"location":"examples/03-parsimonious-flux-balance/#Parsimonious-flux-balance-analysis","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"","category":"section"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"We will use parsimonious_flux_balance_analysis and minimize_metabolic_adjustment to find the optimal flux distribution in the E. coli \"core\" model.","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"TODO pFBA citation","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"If it is not already present, download the model and load the package:","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"import Downloads: download\n\n!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\")","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"next, load the necessary packages","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"using COBREXA\n\nimport JSONFBCModels\nimport Clarabel # can solve QPs\n\nmodel = load_model(\"e_coli_core.json\") # load the model","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"Use the convenience function to run standard pFBA on","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"vt = parsimonious_flux_balance_analysis(model, Clarabel.Optimizer; settings = [silence])","category":"page"},{"location":"examples/03-parsimonious-flux-balance/#Alternatively,-you-can-construct-your-own-constraint-tree-model-with","page":"Parsimonious flux balance analysis","title":"Alternatively, you can construct your own constraint tree model with","text":"","category":"section"},{"location":"examples/03-parsimonious-flux-balance/#the-quadratic-objective-(this-approach-is-much-more-flexible).","page":"Parsimonious flux balance analysis","title":"the quadratic objective (this approach is much more flexible).","text":"","category":"section"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"ctmodel = fluxbalanceconstraints(model) ctmodel *= :l2objective^squaredsumvalue(ctmodel.fluxes) ctmodel.objective.bound = 0.3 # set growth rate # TODO currently breaks","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"optmodel = optimizationmodel(     ctmodel;     objective = ctmodel.:l2objective.value,     optimizer = Clarabel.Optimizer,     sense = Minimal, )","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"J.optimize!(opt_model) # JuMP is called J in COBREXA","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"issolved(optmodel) # check if solved","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"vt = C.substitutevalues(ctmodel, J.value.(optmodel[:x])) # ConstraintTrees.jl is called C in COBREXA","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"@test isapprox(vt.l2objective, ?; atol = QPTESTTOLERANCE) #src  # TODO will break until mutable bounds","category":"page"},{"location":"examples/03-parsimonious-flux-balance/#It-is-likewise-as-simple-to-run-MOMA-using-the-convenience-functions.","page":"Parsimonious flux balance analysis","title":"It is likewise as simple to run MOMA using the convenience functions.","text":"","category":"section"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"ref_sol = Dict(\"ATPS4r\" => 33.0, \"CYTBD\" => 22.0)","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"vt = minimizemetabolicadjustment(model, ref_sol, Gurobi.Optimizer)","category":"page"},{"location":"examples/03-parsimonious-flux-balance/#Or-use-the-piping-functionality","page":"Parsimonious flux balance analysis","title":"Or use the piping functionality","text":"","category":"section"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"model |> minimizemetabolicadjustment(ref_sol, Clarabel.Optimizer; settings = [silence])","category":"page"},{"location":"examples/03-parsimonious-flux-balance/#Alternatively,-you-can-construct-your-own-constraint-tree-model-with-2","page":"Parsimonious flux balance analysis","title":"Alternatively, you can construct your own constraint tree model with","text":"","category":"section"},{"location":"examples/03-parsimonious-flux-balance/#the-quadratic-objective-(this-approach-is-much-more-flexible).-2","page":"Parsimonious flux balance analysis","title":"the quadratic objective (this approach is much more flexible).","text":"","category":"section"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"ctmodel = fluxbalanceconstraints(model) ctmodel *=     :minoxphospho^squaredsumerror_value(         ctmodel.fluxes,         Dict(:ATPS4r => 33.0, :CYTBD => 22.0),     ) ctmodel.objective.bound = 0.3 # set growth rate # TODO currently breaks","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"optmodel = optimizationmodel(     ctmodel;     objective = ctmodel.minoxphospho.value,     optimizer = Clarabel.Optimizer,     sense = Minimal, )","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"J.optimize!(opt_model) # JuMP is called J in COBREXA","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"issolved(optmodel) # check if solved","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"vt = C.substitutevalues(ctmodel, J.value.(optmodel[:x])) # ConstraintTrees.jl is called C in COBREXA","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"@test isapprox(vt.l2objective, ?; atol = QPTESTTOLERANCE) #src  # TODO will break until mutable bounds","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"","category":"page"},{"location":"examples/03-parsimonious-flux-balance/","page":"Parsimonious flux balance analysis","title":"Parsimonious flux balance analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"distributed/3_slurm/#Working-in-a-HPC-environment","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"","category":"section"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"Many researchers have access to institutional HPC facilities that allow time-sharing of the capacity of a large computer cluster between many users. Julia and COBREXA.jl work well within this environment, and the COBREXA analyses usually require only minimal additional customization to be able to find and utilize the resources available from the HPC.","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"When executed in a HPC environment, the analysis script must solve several relatively complex tasks:","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"It needs to find out how many resources were allocated for the analysis\nIt needs to add the remote workers precisely at the allocated places","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"Fortunately, the package ClusterManagers.jl does that for us. For simplicily, here we assume that your HPC is scheduled by Slurm, but other scheduling environments are supported in a very similar way.","category":"page"},{"location":"distributed/3_slurm/#Interacting-with-Slurm","page":"Working in a HPC environment","title":"Interacting with Slurm","text":"","category":"section"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"Adding of the Slurm-provided is done as follows:","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"you import the ClusterManagers package\nyou find how many processes to spawn from the environment from SLURM_NTASKS environment variable\nyou use the function addprocs_slurm to precisely connect to your allocated computational resources","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"After adding the Slurm workers, you may continue as if the workers were added using normal addprocs –- typically you load the model and (for example) run the flux_variability_analysis as if you would use the local workers.","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"The Julia script that does a parallel analysis in a Slurm cluster may look as follows:","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"using COBREXA, Distributed, ClusterManagers, GLPK\n\navailable_workers = parse(Int, ENV[\"SLURM_NTASKS\"])\n\naddprocs_slurm(available_workers)\n\n# ... load models, prepare data, etc. ...\n\nresult = flux_variability_analysis(...; workers=workers())\n\n# ... save the results into a file ...","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"tip: What about the other HPC schedulers?\nClusterManagers.jl supports many other common HPC scheduling systems, including LFS, Sun Grid, SGE, PBS, and Scyld, in a way almost identical to Slurm. See the package documentation for details.","category":"page"},{"location":"distributed/3_slurm/#Wrapping-your-script-in-a-Slurm-batch-job","page":"Working in a HPC environment","title":"Wrapping your script in a Slurm batch job","text":"","category":"section"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"To be able to submit your script for later processing using the sbatch Slurm command, you need to wrap it in a small \"batch\" script that tells Slurm how many resources the process needs.","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"Assuming you have a Julia computation script written down in myJob.jl and saved on your HPC cluster's access node, the corresponding Slurm batch script (let's call it myJob.sbatch) may look as follows:","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"#!/bin/bash -l\n#SBATCH -n 100           # the job will require 100 individual workers\n#SBATCH -c 1             # each worker will sit on a single CPU\n#SBATCH -t 30            # the whole job will take less than 30 minutes\n#SBATCH -J myJob         # the name of the job\n\nmodule load lang/Julia   # this is usually required to make Julia available to your job\n\njulia myJob.jl","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"To run the computation, simply run sbatch myJob.sbatch on the cluster access node.  The job will be scheduled and eventually executed. You may watch the output of commands sacct and squeue in the meantime, to see the progress.","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"Remember that you need to explicitly save the result of your Julia script computation to files, to be able to retrieve them later. Standard outputs of the jobs are often mangled and discarded. If you still want to collect the standard output of your Julia script, you may change the last line of the batch script to","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"julia myJob.jl > myJob.log","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"and collect the output from myJob.log later. This is convenient especially if your script logs various computation details using @info and similar macros.","category":"page"},{"location":"examples/01-loading-and-saving/","page":"Loading and saving models!","title":"Loading and saving models!","text":"EditURL = \"01-loading-and-saving.jl\"","category":"page"},{"location":"examples/01-loading-and-saving/#Loading-and-saving-models!","page":"Loading and saving models!","title":"Loading and saving models!","text":"","category":"section"},{"location":"examples/01-loading-and-saving/","page":"Loading and saving models!","title":"Loading and saving models!","text":"using COBREXA","category":"page"},{"location":"examples/01-loading-and-saving/","page":"Loading and saving models!","title":"Loading and saving models!","text":"TODO: download the models into a single directory that can get cached. Probably best have a fake mktempdir().","category":"page"},{"location":"examples/01-loading-and-saving/","page":"Loading and saving models!","title":"Loading and saving models!","text":"TODO: demonstrate download_model here and explain how to get hashes (simply not fill them in for the first time)","category":"page"},{"location":"examples/01-loading-and-saving/","page":"Loading and saving models!","title":"Loading and saving models!","text":"","category":"page"},{"location":"examples/01-loading-and-saving/","page":"Loading and saving models!","title":"Loading and saving models!","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/02-flux-balance-analysis/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"EditURL = \"02-flux-balance-analysis.jl\"","category":"page"},{"location":"examples/02-flux-balance-analysis/#Flux-balance-analysis-(FBA)","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"","category":"section"},{"location":"examples/02-flux-balance-analysis/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"Here we use flux_balance_analysis and several related functions to find an optimal flux in the E. coli \"core\" model. We will need the model, which we can download using download_model:","category":"page"},{"location":"examples/02-flux-balance-analysis/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"using COBREXA\n\ndownload_model(\n    \"http://bigg.ucsd.edu/static/models/e_coli_core.json\",\n    \"e_coli_core.json\",\n    \"7bedec10576cfe935b19218dc881f3fb14f890a1871448fc19a9b4ee15b448d8\",\n)","category":"page"},{"location":"examples/02-flux-balance-analysis/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"Additionally to COBREXA and the model format package, we will need a solver – let's use GLPK here:","category":"page"},{"location":"examples/02-flux-balance-analysis/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"import JSONFBCModels\nimport GLPK\n\nmodel = load_model(\"e_coli_core.json\")","category":"page"},{"location":"examples/02-flux-balance-analysis/#Running-a-FBA","page":"Flux balance analysis (FBA)","title":"Running a FBA","text":"","category":"section"},{"location":"examples/02-flux-balance-analysis/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"There are many possibilities on how to arrange the metabolic model into the optimization framework and how to actually solve it. The \"usual\" assumed one is captured in the default behavior of function flux_balance_analysis:","category":"page"},{"location":"examples/02-flux-balance-analysis/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"solution = flux_balance_analysis(model, GLPK.Optimizer)","category":"page"},{"location":"examples/02-flux-balance-analysis/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"The result contains a tree of all optimized values in the model, including fluxes, the objective value, and possibly others (given by what the model contains).","category":"page"},{"location":"examples/02-flux-balance-analysis/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"You can explore the dot notation to explore the solution, extracting e.g. the value of the objective:","category":"page"},{"location":"examples/02-flux-balance-analysis/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"solution.objective","category":"page"},{"location":"examples/02-flux-balance-analysis/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"...or the value of the flux through the given reaction (note the solution is not unique in FBA):","category":"page"},{"location":"examples/02-flux-balance-analysis/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"solution.fluxes.PFK","category":"page"},{"location":"examples/02-flux-balance-analysis/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"...or make a \"table\" of all fluxes through all reactions:","category":"page"},{"location":"examples/02-flux-balance-analysis/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"collect(solution.fluxes)","category":"page"},{"location":"examples/02-flux-balance-analysis/#Advanced:-Finding-flux-balance-via-the-low-level-interface","page":"Flux balance analysis (FBA)","title":"Advanced: Finding flux balance via the low-level interface","text":"","category":"section"},{"location":"examples/02-flux-balance-analysis/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"TODO ConstraintTrees (maybe put this into a separate example?)","category":"page"},{"location":"examples/02-flux-balance-analysis/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"","category":"page"},{"location":"examples/02-flux-balance-analysis/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"concepts/1_screen/#Screening-many-model-variants","page":"Screening many model variants","title":"Screening many model variants","text":"","category":"section"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"A major goal of COBREXA.jl is to make exploring of many model variants easy and fast.","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"One main concept that can be utilized for doing that is implemented in the function screen, which takes your model, a list of model variants that you want to explore by some specified analysis, and schedules the analysis of the model variants parallelly on the available distributed workers.","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"In its most basic form, the \"screening\" may use the slightly simplified variant of screen that is called screen_variants, which works as follows:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"m = load_model(ObjectModel, \"e_coli_core.json\")\n\nscreen_variants(\n    m,    # the model for screening\n    [\n        [],    # a variant with no modifications\n        [with_changed_bound(\"CO2t\", lb = 0, ub = 0)],  # disable CO2 transport\n        [with_changed_bound(\"O2t\", lb = 0, ub = 0)],  # disable O2 transport\n        [with_changed_bound(\"CO2t\", lb = 0, ub = 0), with_changed_bound(\"O2t\", lb = 0, ub = 0)],  # disable both transports\n    ],\n    m -> flux_balance_dict(m, Tulip.Optimizer)[\"BIOMASS_Ecoli_core_w_GAM\"],\n)","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"The call specifies a model (the m that we have loaded) that is being tested, then a vector of model variants to be created and tested, and then the analysis that is being run on each variant – in this case, we find an optimal steady state of each of the variants, and check out the biomass production rate at that state. In this particular case, we are checking what will be the effect of disabling combinations of CO2 transport and O2 transport in the cells. For that, we get the following result:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"4-element Vector{Float64}:\n 0.8739215022678488\n 0.46166961413944896\n 0.21166294973372135\n 0.21114065173865518","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"The numbers are the biomass production rates for the specified variants. We can see that disabling O2 transport really does not help the organism much.","category":"page"},{"location":"concepts/1_screen/#Variant-specification","page":"Screening many model variants","title":"Variant specification","text":"","category":"section"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"In the above example, we have specified 4 variants, thus the analysis returned 4 different results that correspond with the specifications. Let us have a look at the precise format of the specification and result.","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"Importantly, the variants argument is of type Array{Vector{Any}}, meaning that it can be an array of any dimensionality that contains vectors. Each of the vectors specifies precisely one variant, possibly with more modifications applied to the model in sequence.","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"For example:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"[] specifies no modifications at all\n[with_changed_bound(\"CO2t\", lb=0, ub=10)] limits the CO2 transport\n[with_changed_bound(\"CO2t\", lb=0, ub=2), with_changed_bound(\"O2t\", lb=0, ub=100)] severely limits the CO2 transport and slightly restricts the transport of O2","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"note: Variants are single-parameter model-transforming functions\nBecause the variants are just generators of single parameter functions that take the model and return its modified version, you can also use identity to specify a variant that does nothing – [identity] is perfectly same as []","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"The shape of the variants array is important too, because it is precisely retained in the result (just as with pmap). If you pass in a matrix of variants, you will receive a matrix of analysis results of the same size. That can be exploited for easily exploring many combinations of possible model properties. Let's try exploring a \"cube\" of possible restricted reactions:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"using IterTools # for cartesian products\n\nres = screen_variants(m,\n    [\n        # for each variant we restricts 2 reactions\n        [with_changed_bound(r1, lb=-3, ub=3), with_changed_bound(r2, lb=-1, ub=1)]\n\n        # the reaction pair will be chosen from a cartesian product\n        for (r1,r2) in product(\n            [\"H2Ot\", \"CO2t\", \"O2t\", \"NH4t\"], # of this set of transport reactions\n            [\"EX_h2o_e\", \"EX_co2_e\", \"EX_o2_e\", \"EX_nh4_e\"], # and this set of exchanges\n        )\n    ],\n    m -> flux_balance_dict(m, Tulip.Optimizer)[\"BIOMASS_Ecoli_core_w_GAM\"],\n)","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"As a result, we will receive a full matrix of the biomass productions:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"4×4 Matrix{Float64}:\n 0.407666  0.454097  0.240106  0.183392\n 0.407666  0.485204  0.24766   0.183392\n 0.314923  0.319654  0.24766   0.183392\n 0.407666  0.485204  0.24766   0.183392","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"Notably, this shows that O2 transport and NH4 exchange may be serious bottlenecks for biomass production.","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"For clarity, you may always annotate the result by zipping it with the specification structure you have used and collecting the data:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"collect(zip(\n    product(\n        [\"H2Ot\", \"CO2t\", \"O2t\", \"NH4t\"],\n        [\"EX_h2o_e\", \"EX_co2_e\", \"EX_o2_e\", \"EX_nh4_e\"],\n    ),\n    res,\n))","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"...which gives the following annotated result:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"4×4 Matrix{Tuple{Tuple{String, String}, Float64}}:\n ((\"H2Ot\", \"EX_h2o_e\"), 0.407666)  ((\"H2Ot\", \"EX_co2_e\"), 0.454097)  ((\"H2Ot\", \"EX_o2_e\"), 0.240106)  ((\"H2Ot\", \"EX_nh4_e\"), 0.183392)\n ((\"CO2t\", \"EX_h2o_e\"), 0.407666)  ((\"CO2t\", \"EX_co2_e\"), 0.485204)  ((\"CO2t\", \"EX_o2_e\"), 0.24766)   ((\"CO2t\", \"EX_nh4_e\"), 0.183392)\n ((\"O2t\", \"EX_h2o_e\"), 0.314923)   ((\"O2t\", \"EX_co2_e\"), 0.319654)   ((\"O2t\", \"EX_o2_e\"), 0.24766)    ((\"O2t\", \"EX_nh4_e\"), 0.183392)\n ((\"NH4t\", \"EX_h2o_e\"), 0.407666)  ((\"NH4t\", \"EX_co2_e\"), 0.485204)  ((\"NH4t\", \"EX_o2_e\"), 0.24766)   ((\"NH4t\", \"EX_nh4_e\"), 0.183392)","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"This may be easily used for e.g. scrutinizing all possible reaction pairs, to find the ones that are redundant and not.","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"There are many other variant \"specifications\" to choose from. You may use with_added_reactions, with_removed_reactions, with_removed_metabolites, and others. Function reference contains a complete list; as a convention, names of the specifications all start with with_.","category":"page"},{"location":"concepts/1_screen/#Writing-custom-variant-functions","page":"Screening many model variants","title":"Writing custom variant functions","text":"","category":"section"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"It is actually very easy to create custom specifications that do any modification that you can implement, to be later used with screen_variants and screen.","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"Generally, the \"specifications\" are supposed to return a function that creates a modified copy of the model. The copy of the model may be shallow, but the functions should always prevent modifying the original model structure – screen is keeping a single copy of the original model at each worker to prevent unnecessary bulk data transport, and if that is changed in-place, all following analyses of the model will work on inconsistent data, usually returning wrong results (even randomly changing ones, because of the asynchronous nature of screen execution).","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"Despite of that, writing a modification is easy. The simplest modification that \"does nothing\" (isomorphic to standard identity) can be formatted as follows:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"with_no_change = model -> model","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"The modifications may change the model, provided it is copied properly. The following modification will remove a reaction called \"O2t\", effectively removing the possibility to transport oxygen. We require a specific type of model where this change is easy to perform (generally, not all variants may be feasible on all model types).","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"with_disabled_oxygen_transport = (model::ObjectModel) -> begin\n\n    # make \"as shallow as possible\" copy of the `model`.\n    # Utilizing `deepcopy` is also possible, but inefficient.\n    new_model = copy(model)\n    new_model.reactions = copy(model.reactions)\n\n    # remove the O2 transport from the model copy\n    delete!(new_model.reactions, \"O2t\")\n\n    return new_model #return the newly created variant\nend","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"Finally, the whole definition may be parameterized as a normal function. The following variant removes any user-selected reaction:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"with_disabled_reaction(reaction_id) = (model::ObjectModel) -> begin\n    new_model = copy(model)\n    new_model.reactions = copy(model.reactions)\n    delete!(new_model.reactions, reaction_id) # use the parameter from the specification\n    return new_model\nend","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"In turn, these variants can be used in screen_variants just as we used with_changed_bound above:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"screen_variants(\n    m,    # the model for screening\n    [\n        [with_no_change],\n        [with_disabled_oxygen_transport],\n        [with_disabled_reaction(\"NH4t\")],\n    ],\n    m -> flux_balance_dict(m, Tulip.Optimizer)[\"BIOMASS_Ecoli_core_w_GAM\"],\n)","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"That should get you the results for all new variants of the model:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"3-element Vector{Float64}:\n 0.8739215022674809\n 0.21166294865468896\n 1.2907224478973395e-15","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"warning: Custom variants with distributed processing\nIf using distributed evaluation, remember the variant-generating functions need to be defined on all used workers (generating the variants in parallel on the workers allows COBREXA to run the screening process very efficiently, without unnecessary sending of bulk model data). Prefixing the definition with @everywhere is usually sufficient for that purpose.","category":"page"},{"location":"concepts/1_screen/#Passing-extra-arguments-to-the-analysis-function","page":"Screening many model variants","title":"Passing extra arguments to the analysis function","text":"","category":"section"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"Some analysis functions may take additional arguments, which you might want to vary for the analysis. modifications argument of flux_balance_dict is one example of such argument, allowing you to specify details of the optimization procedure.","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"screen function allows you to do precisely that – apart from variants, you may also specify an array of args of the same shape as variants, the entries of which will get passed together with the generated model variants to your specified analysis function. If either of the arguments is missing (or set to nothing), it is defaulted to \"no modifications\" or \"no arguments\".","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"The arguments must be tuples; you may need to make 1-tuples from your data (e.g. using (value,)) if you want to pass just a single argument.","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"Let's try to use that functionality for trying to find a sufficient amount of iterations needed for Tulip solver to find a feasible solution:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"screen(m,\n    args = [(i,) for i in 5:15],  # the iteration counts, packed in 1-tuples\n    analysis = (m,a) -> # `args` elements get passed as the extra parameter here\n        flux_balance_vec(m,\n            Tulip.Optimizer;\n            modifications=[modify_optimizer_attribute(\"IPM_IterationsLimit\", a)],\n        ),\n)","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"From the result, we can see that Tulip would need at least 14 iterations to find a feasible region:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"11-element Vector{Union{Nothing, Vector{Float64}}}:\n nothing\n nothing\n nothing\n nothing\n nothing\n nothing\n nothing\n nothing\n nothing\n [7.47738193404817, 1.8840414375838503e-8, 4.860861010127701, -16.023526104614593, … ]\n [7.47738193404817, 1.8840414375838503e-8, 4.860861010127701, -16.023526104614593, … ]","category":"page"},{"location":"examples/04-minimization-of-metabolic-adjustment/","page":"Minimization of metabolic adjustment analysis","title":"Minimization of metabolic adjustment analysis","text":"EditURL = \"04-minimization-of-metabolic-adjustment.jl\"","category":"page"},{"location":"examples/04-minimization-of-metabolic-adjustment/#Minimization-of-metabolic-adjustment-analysis","page":"Minimization of metabolic adjustment analysis","title":"Minimization of metabolic adjustment analysis","text":"","category":"section"},{"location":"examples/04-minimization-of-metabolic-adjustment/","page":"Minimization of metabolic adjustment analysis","title":"Minimization of metabolic adjustment analysis","text":"TODO MOMA citation","category":"page"},{"location":"examples/04-minimization-of-metabolic-adjustment/","page":"Minimization of metabolic adjustment analysis","title":"Minimization of metabolic adjustment analysis","text":"import Downloads: download\n\n!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\")\n\nusing COBREXA\nimport AbstractFBCModels.CanonicalModel as CM\nimport JSONFBCModels\nimport Clarabel","category":"page"},{"location":"examples/04-minimization-of-metabolic-adjustment/","page":"Minimization of metabolic adjustment analysis","title":"Minimization of metabolic adjustment analysis","text":"TODO this might do the convert immediately as with the old cobrexa... probably better have an actual output-type argument tho rather than force the guessing.","category":"page"},{"location":"examples/04-minimization-of-metabolic-adjustment/","page":"Minimization of metabolic adjustment analysis","title":"Minimization of metabolic adjustment analysis","text":"model = convert(CM.Model, load_model(\"e_coli_core.json\"))\n\nreference_fluxes =\n    parsimonious_flux_balance_analysis(\n        model,\n        Clarabel.Optimizer,\n        settings = [silence],\n    ).fluxes","category":"page"},{"location":"examples/04-minimization-of-metabolic-adjustment/","page":"Minimization of metabolic adjustment analysis","title":"Minimization of metabolic adjustment analysis","text":"TODO MOMA from here","category":"page"},{"location":"examples/04-minimization-of-metabolic-adjustment/","page":"Minimization of metabolic adjustment analysis","title":"Minimization of metabolic adjustment analysis","text":"","category":"page"},{"location":"examples/04-minimization-of-metabolic-adjustment/","page":"Minimization of metabolic adjustment analysis","title":"Minimization of metabolic adjustment analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/02c-constraint-modifications/","page":"Making adjustments to the constraint system","title":"Making adjustments to the constraint system","text":"EditURL = \"02c-constraint-modifications.jl\"","category":"page"},{"location":"examples/02c-constraint-modifications/#Making-adjustments-to-the-constraint-system","page":"Making adjustments to the constraint system","title":"Making adjustments to the constraint system","text":"","category":"section"},{"location":"examples/02c-constraint-modifications/","page":"Making adjustments to the constraint system","title":"Making adjustments to the constraint system","text":"In the previous example about model adjustments, we noted that some constraint systems may be to complex to be changed within the limits of the usual FBC model view, and we may require a sharper tool to do the changes we need. This example shows how to do that by modifying the constraint systems that are generated within COBREXA to represent the metabolic model contents.","category":"page"},{"location":"examples/02c-constraint-modifications/#Background:-Model-to-optimizer-pipeline","page":"Making adjustments to the constraint system","title":"Background: Model-to-optimizer pipeline","text":"","category":"section"},{"location":"examples/02c-constraint-modifications/#Background:-Constraint-trees","page":"Making adjustments to the constraint system","title":"Background: Constraint trees","text":"","category":"section"},{"location":"examples/02c-constraint-modifications/#Changing-the-model-to-optimizer-pipeline","page":"Making adjustments to the constraint system","title":"Changing the model-to-optimizer pipeline","text":"","category":"section"},{"location":"examples/02c-constraint-modifications/","page":"Making adjustments to the constraint system","title":"Making adjustments to the constraint system","text":"TODO clean up the stuff below:","category":"page"},{"location":"examples/02c-constraint-modifications/","page":"Making adjustments to the constraint system","title":"Making adjustments to the constraint system","text":"using COBREXA\n\ndownload_model(\n    \"http://bigg.ucsd.edu/static/models/e_coli_core.json\",\n    \"e_coli_core.json\",\n    \"7bedec10576cfe935b19218dc881f3fb14f890a1871448fc19a9b4ee15b448d8\",\n)\n\nimport JSONFBCModels\nimport GLPK\n\nmodel = load_model(\"e_coli_core.json\")","category":"page"},{"location":"examples/02c-constraint-modifications/#Customizing-the-model","page":"Making adjustments to the constraint system","title":"Customizing the model","text":"","category":"section"},{"location":"examples/02c-constraint-modifications/","page":"Making adjustments to the constraint system","title":"Making adjustments to the constraint system","text":"We can also modify the model. The most explicit way to do this is to make a new constraint tree representation of the model.","category":"page"},{"location":"examples/02c-constraint-modifications/","page":"Making adjustments to the constraint system","title":"Making adjustments to the constraint system","text":"import ConstraintTrees as C\n\nctmodel = flux_balance_constraints(model)\n\nfermentation = ctmodel.fluxes.EX_ac_e.value + ctmodel.fluxes.EX_etoh_e.value\n\nforced_mixed_fermentation =\n    ctmodel * :fermentation^C.Constraint(fermentation, (10.0, 1000.0)) # new modified model is created\n\nvt = optimized_values(\n    forced_mixed_fermentation,\n    objective = forced_mixed_fermentation.objective.value,\n    optimizer = GLPK.Optimizer,\n)","category":"page"},{"location":"examples/02c-constraint-modifications/","page":"Making adjustments to the constraint system","title":"Making adjustments to the constraint system","text":"Models that cannot be solved return nothing. In the example below, the underlying model is modified.","category":"page"},{"location":"examples/02c-constraint-modifications/","page":"Making adjustments to the constraint system","title":"Making adjustments to the constraint system","text":"ctmodel.fluxes.ATPM.bound = C.Between(1000.0, 10000.0)\n\n#TODO explicitly show here how false sharing looks like\n\nvt = optimized_values(\n    ctmodel,\n    objective = ctmodel.objective.value,\n    optimizer = GLPK.Optimizer,\n)","category":"page"},{"location":"examples/02c-constraint-modifications/","page":"Making adjustments to the constraint system","title":"Making adjustments to the constraint system","text":"Models can also be piped into the analysis functions","category":"page"},{"location":"examples/02c-constraint-modifications/","page":"Making adjustments to the constraint system","title":"Making adjustments to the constraint system","text":"ctmodel.fluxes.ATPM.bound = C.Between(8.39, 10000.0) # revert\nvt = optimized_values(\n    ctmodel,\n    objective = ctmodel.objective.value,\n    optimizer = GLPK.Optimizer,\n)","category":"page"},{"location":"examples/02c-constraint-modifications/","page":"Making adjustments to the constraint system","title":"Making adjustments to the constraint system","text":"","category":"page"},{"location":"examples/02c-constraint-modifications/","page":"Making adjustments to the constraint system","title":"Making adjustments to the constraint system","text":"This page was generated using Literate.jl.","category":"page"},{"location":"concepts/#Core-concepts-and-extension-guide","page":"Contents","title":"Core concepts and extension guide","text":"","category":"section"},{"location":"concepts/","page":"Contents","title":"Contents","text":"Pages = filter(x -> endswith(x, \".md\"), readdir(\"concepts\", join=true))\nDepth = 2","category":"page"},{"location":"examples/07-loopless-models/","page":"Loopless flux balance analysis (ll-FBA)","title":"Loopless flux balance analysis (ll-FBA)","text":"EditURL = \"07-loopless-models.jl\"","category":"page"},{"location":"examples/07-loopless-models/#Loopless-flux-balance-analysis-(ll-FBA)","page":"Loopless flux balance analysis (ll-FBA)","title":"Loopless flux balance analysis (ll-FBA)","text":"","category":"section"},{"location":"examples/07-loopless-models/","page":"Loopless flux balance analysis (ll-FBA)","title":"Loopless flux balance analysis (ll-FBA)","text":"Here we wil add loopless constraints to a flux balance model to ensure that the resultant solution is thermodynamically consistent. As before, we will use the core E. coli model, which we can download using download_model:","category":"page"},{"location":"examples/07-loopless-models/","page":"Loopless flux balance analysis (ll-FBA)","title":"Loopless flux balance analysis (ll-FBA)","text":"using COBREXA\n\ndownload_model(\n    \"http://bigg.ucsd.edu/static/models/e_coli_core.json\",\n    \"e_coli_core.json\",\n    \"7bedec10576cfe935b19218dc881f3fb14f890a1871448fc19a9b4ee15b448d8\",\n)","category":"page"},{"location":"examples/07-loopless-models/","page":"Loopless flux balance analysis (ll-FBA)","title":"Loopless flux balance analysis (ll-FBA)","text":"Additionally to COBREXA and the JSON model format package. We will also need a solver that can solve mixed interger linear programs like GLPK.","category":"page"},{"location":"examples/07-loopless-models/","page":"Loopless flux balance analysis (ll-FBA)","title":"Loopless flux balance analysis (ll-FBA)","text":"import JSONFBCModels\nimport GLPK\n\nmodel = load_model(\"e_coli_core.json\")","category":"page"},{"location":"examples/07-loopless-models/#Running-a-loopless-FBA-(ll-FBA)","page":"Loopless flux balance analysis (ll-FBA)","title":"Running a loopless FBA (ll-FBA)","text":"","category":"section"},{"location":"examples/07-loopless-models/","page":"Loopless flux balance analysis (ll-FBA)","title":"Loopless flux balance analysis (ll-FBA)","text":"One can directly use loopless_flux_balance_analysis to solve an FBA problem based on model where loopless constraints are added to all fluxes. This is the direct approach.","category":"page"},{"location":"examples/07-loopless-models/","page":"Loopless flux balance analysis (ll-FBA)","title":"Loopless flux balance analysis (ll-FBA)","text":"solution = loopless_flux_balance_analysis(model; optimizer = GLPK.Optimizer)","category":"page"},{"location":"examples/07-loopless-models/","page":"Loopless flux balance analysis (ll-FBA)","title":"Loopless flux balance analysis (ll-FBA)","text":"","category":"page"},{"location":"examples/07-loopless-models/","page":"Loopless flux balance analysis (ll-FBA)","title":"Loopless flux balance analysis (ll-FBA)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/solver/#Solver-interface","page":"Solver interface","title":"Solver interface","text":"","category":"section"},{"location":"reference/solver/","page":"Solver interface","title":"Solver interface","text":"Modules = [COBREXA]\nPages = [\"src/solver.jl\"]","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"EditURL = \"08-community-models.jl\"","category":"page"},{"location":"examples/08-community-models/#Community-FBA-models","page":"Community FBA models","title":"Community FBA models","text":"","category":"section"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"using COBREXA","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"Here we will construct a community FBA model of two  E. coli \"core\" models that can interact by exchanging selected metabolites. To do this, we will need the model, which we can download if it is not already present.","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"import Downloads: download\n\n!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\")","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"Additionally to COBREXA and the model format package, we will need a solver – let's use GLPK here:","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"import JSONFBCModels\nimport GLPK\nimport ConstraintTrees as C\n\nmodel = load_model(\"e_coli_core.json\")","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"Community models work by joining its members together through their exchange reactions, weighted by the abundance of each microbe. These exchange reactions are then linked to an environmental exchange. For more theoretical details, see \"Gottstein, et al, 2016, Constraint-based stoichiometric modelling from single organisms to microbial communities, Journal of the Royal Society Interface\".","category":"page"},{"location":"examples/08-community-models/#Building-a-community-of-two-*E.-coli*s","page":"Community FBA models","title":"Building a community of two E. colis","text":"","category":"section"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"Here we will construct a simple community of two interacting microbes. To do this, we need to import the models. We will represent the models only as constraint trees, because it is easier to build the model explicitly than rely on an opaque one-shot function.","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"ecoli1 = flux_balance_constraints(model, interface = :sbo)\necoli2 = flux_balance_constraints(model, interface = :sbo)","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"Since the models are usually used in a mono-culture context, the glucose input for each individual member is limited. We need to undo this limitation, and rather rely on the constrained environmental exchange reaction (and the bounds we set for it earlier).","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"ecoli1.fluxes.EX_glc__D_e.bound = C.Between(-1000.0, 1000.0)\necoli2.fluxes.EX_glc__D_e.bound = C.Between(-1000.0, 1000.0)","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"To make the community interesting, we can limit different reactions in both members to see how the  models cope together:","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"ecoli1.fluxes.CYTBD.bound = C.Between(-10.0, 10.0)\necoli2.fluxes.ACALD.bound = C.Between(-5.0, 5.0)","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"Because we created the trees with interfaces, we can connect them easily to form a new model with the interface. For simplicity, we use the interface-scaling functionality of interface_constraints to bring in cFBA-like community member abundances:","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"cc = interface_constraints(\n    :bug1 => (ecoli1, ecoli1.interface, 0.2),\n    :bug2 => (ecoli2, ecoli2.interface, 0.8),\n)","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"To make the community behave as expected, we need to force equal (scaled) growth of all members:","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"cc *=\n    :equal_growth^equal_value_constraint(\n        cc.bug1.fluxes.BIOMASS_Ecoli_core_w_GAM,\n        cc.bug2.fluxes.BIOMASS_Ecoli_core_w_GAM,\n    )","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"Now we can simulate the community growth by optimizing the new \"interfaced\" biomass:","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"optimized_cc = optimized_values(\n    cc,\n    objective = cc.interface.biomass.BIOMASS_Ecoli_core_w_GAM.value,\n    optimizer = GLPK.Optimizer,\n)","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"We can now e.g. observe the differences in individual pairs of exchanges:","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"C.zip(\n    tuple,\n    optimized_cc.bug1.interface.exchanges,\n    optimized_cc.bug2.interface.exchanges,\n    Tuple{Float64,Float64},\n)","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"","category":"page"},{"location":"examples/08-community-models/","page":"Community FBA models","title":"Community FBA models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/06-mmdf/","page":"Thermodynamic models","title":"Thermodynamic models","text":"EditURL = \"06-mmdf.jl\"","category":"page"},{"location":"examples/06-mmdf/#Thermodynamic-models","page":"Thermodynamic models","title":"Thermodynamic models","text":"","category":"section"},{"location":"examples/06-mmdf/","page":"Thermodynamic models","title":"Thermodynamic models","text":"using COBREXA","category":"page"},{"location":"examples/06-mmdf/","page":"Thermodynamic models","title":"Thermodynamic models","text":"Here we will solve the max min driving force analysis problem using the glycolysis pathway of E. coli. In essence, the method attempts to find metabolite concentrations (NB: not fluxes) that maximize the smallest thermodynamic driving force through each reaction. See Noor, et al., \"Pathway","category":"page"},{"location":"examples/06-mmdf/","page":"Thermodynamic models","title":"Thermodynamic models","text":"#thermodynamics highlights kinetic obstacles in central metabolism.\", PLoS\n#computational biology, 2014, for more details.","category":"page"},{"location":"examples/06-mmdf/","page":"Thermodynamic models","title":"Thermodynamic models","text":"To do this, we will first need a model that includes glycolysis, which we can download if it is not already present.","category":"page"},{"location":"examples/06-mmdf/","page":"Thermodynamic models","title":"Thermodynamic models","text":"import Downloads: download\n\n#TODO use AFBCMs functionality\n!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\")","category":"page"},{"location":"examples/06-mmdf/","page":"Thermodynamic models","title":"Thermodynamic models","text":"Additionally to COBREXA, and the model format package, we will need a solver – let's use GLPK here:","category":"page"},{"location":"examples/06-mmdf/","page":"Thermodynamic models","title":"Thermodynamic models","text":"using COBREXA\nimport JSONFBCModels\nimport GLPK\n\nmodel = load_model(\"e_coli_core.json\")","category":"page"},{"location":"examples/06-mmdf/#Thermodynamic-data","page":"Thermodynamic models","title":"Thermodynamic data","text":"","category":"section"},{"location":"examples/06-mmdf/","page":"Thermodynamic models","title":"Thermodynamic models","text":"We will need ΔᵣG⁰ data for each reaction we want to include in the thermodynamic model. To generate this data manually, go to https://equilibrator.weizmann.ac.il/. To generate automatically, you may use the eQuilibrator.jl package.","category":"page"},{"location":"examples/06-mmdf/","page":"Thermodynamic models","title":"Thermodynamic models","text":"reaction_standard_gibbs_free_energies = Dict{String,Float64}(\n    \"ENO\" => -3.8108376097261782,\n    \"FBA\" => 23.376920310319235,\n    \"GAPD\" => 0.5307809794271634,\n    \"GLCpts\" => -45.42430981510088,\n    \"LDH_D\" => 20.04059765689044,\n    \"PFK\" => -18.546314942995934,\n    \"PGI\" => 2.6307087407442395,\n    \"PGK\" => 19.57192102020454,\n    \"PGM\" => -4.470553692565886,\n    \"PYK\" => -24.48733600711958,\n    \"TPI\" => 5.621932460512994,\n)","category":"page"},{"location":"examples/06-mmdf/","page":"Thermodynamic models","title":"Thermodynamic models","text":"(The units of the energies are kJ/mol.)","category":"page"},{"location":"examples/06-mmdf/#Running-basic-max-min-driving-force-analysis","page":"Thermodynamic models","title":"Running basic max min driving force analysis","text":"","category":"section"},{"location":"examples/06-mmdf/","page":"Thermodynamic models","title":"Thermodynamic models","text":"If a reference flux is not specified, it is assumed that every reaction in the model should be included in the thermodynamic model, and that each reaction proceeds in the forward direction. This is usually not intended, and can be prevented by inputting a reference flux dictionary as shown below. This dictionary can be a flux solution, the sign of each flux is used to determine if the reaction runs forward or backward.","category":"page"},{"location":"examples/06-mmdf/#Using-a-reference-solution","page":"Thermodynamic models","title":"Using a reference solution","text":"","category":"section"},{"location":"examples/06-mmdf/","page":"Thermodynamic models","title":"Thermodynamic models","text":"Frequently it is useful to check the max-min driving force of a specific FBA solution. In this case, one is usually only interested in a subset of all the reactions in a model. These reactions can be specified as a the reference_flux, to only compute the MMDF of these reactions, and ignore all other reactions.","category":"page"},{"location":"examples/06-mmdf/","page":"Thermodynamic models","title":"Thermodynamic models","text":"reference_flux = Dict(\n    \"ENO\" => 1.0,\n    \"FBA\" => 1.0,\n    \"GAPD\" => 1.0,\n    \"GLCpts\" => 1.0,\n    \"LDH_D\" => -1.0,\n    \"PFK\" => 1.0,\n    \"PGI\" => 1.0,\n    \"PGK\" => -1.0,\n    \"PGM\" => -1.0,\n    \"PYK\" => 1.0,\n    \"TPI\" => 1.0,\n)\n\n#!!! warning \"Only the signs are extracted from the reference solution\"","category":"page"},{"location":"examples/06-mmdf/","page":"Thermodynamic models","title":"Thermodynamic models","text":"It is most convenient to pass a flux solution into reference_flux, but take care to round fluxes near 0 to their correct sign if they should be included in the resultant thermodynamic model. Otherwise, remove them from reference flux input.","category":"page"},{"location":"examples/06-mmdf/#Solving-the-MMDF-problem","page":"Thermodynamic models","title":"Solving the MMDF problem","text":"","category":"section"},{"location":"examples/06-mmdf/","page":"Thermodynamic models","title":"Thermodynamic models","text":"mmdf_solution = max_min_driving_force_analysis(\n    model,\n    reaction_standard_gibbs_free_energies;\n    reference_flux,\n    concentration_ratios = Dict(\n        \"atp\" => (\"atp_c\", \"adp_c\", 10.0),\n        \"nadh\" => (\"nadh_c\", \"nad_c\", 0.13),\n    ),\n    proton_metabolites = [\"h_c\", \"h_e\"],\n    water_metabolites = [\"h2o_c\", \"h2o_e\"],\n    concentration_lower_bound = 1e-6, # M\n    concentration_upper_bound = 1e-1, # M\n    T = 298.15, # Kelvin\n    R = 8.31446261815324e-3, # kJ/K/mol\n    optimizer = GLPK.Optimizer,\n)","category":"page"},{"location":"examples/06-mmdf/","page":"Thermodynamic models","title":"Thermodynamic models","text":"TODO verify correctness","category":"page"},{"location":"examples/06-mmdf/","page":"Thermodynamic models","title":"Thermodynamic models","text":"","category":"page"},{"location":"examples/06-mmdf/","page":"Thermodynamic models","title":"Thermodynamic models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"EditURL = \"05-enzyme-constrained-models.jl\"","category":"page"},{"location":"examples/05-enzyme-constrained-models/#Enzyme-constrained-models","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"","category":"section"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"using COBREXA","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"Here we will construct an enzyme constrained variant of the E. coli \"core\" model. We will need the model, which we can download if it is not already present.","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"import Downloads: download\n\n!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\")","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"Additionally to COBREXA and the model format package, we will need a solver – let's use GLPK here:","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"import AbstractFBCModels as A\nimport JSONFBCModels\nimport GLPK\n\nmodel = load_model(\"e_coli_core.json\")","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"Enzyme constrained models require parameters that are usually not used by conventional constraint based models. These include reaction specific turnover numbers, molar masses of enzymes, and capacity bounds.","category":"page"},{"location":"examples/05-enzyme-constrained-models/#Reaction-turnover-numbers","page":"Enzyme constrained models","title":"Reaction turnover numbers","text":"","category":"section"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"Enzyme constrained models require reaction turnover numbers, which are often isozyme specfic. Many machine learning tools, or experimental data sets, can be used to estimate these parameters.","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"<details><summary><strong>Data for reaction turnover numbers</strong></summary>","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"This data is taken from: Heckmann, David, et al. \"Machine learning applied to enzyme turnover numbers reveals protein structural correlates and improves metabolic models.\" Nature communications 9.1 (2018): 1-10.","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"const ecoli_core_reaction_kcats = Dict(\n    \"ACALD\" => 568.11,\n    \"PTAr\" => 1171.97,\n    \"ALCD2x\" => 75.95,\n    \"PDH\" => 529.76,\n    \"MALt2_2\" => 234.03,\n    \"CS\" => 113.29,\n    \"PGM\" => 681.4,\n    \"TKT1\" => 311.16,\n    \"ACONTa\" => 191.02,\n    \"GLNS\" => 89.83,\n    \"ICL\" => 17.45,\n    \"FBA\" => 373.42,\n    \"FORt2\" => 233.93,\n    \"G6PDH2r\" => 589.37,\n    \"AKGDH\" => 264.48,\n    \"TKT2\" => 467.42,\n    \"FRD7\" => 90.20,\n    \"SUCOAS\" => 18.49,\n    \"ICDHyr\" => 39.62,\n    \"AKGt2r\" => 234.99,\n    \"GLUSy\" => 33.26,\n    \"TPI\" => 698.30,\n    \"FORt\" => 234.38,\n    \"ACONTb\" => 159.74,\n    \"GLNabc\" => 233.80,\n    \"RPE\" => 1772.485,\n    \"ACKr\" => 554.61,\n    \"THD2\" => 24.73,\n    \"PFL\" => 96.56,\n    \"RPI\" => 51.77,\n    \"D_LACt2\" => 233.51,\n    \"TALA\" => 109.05,\n    \"PPCK\" => 218.42,\n    \"PGL\" => 2120.42,\n    \"NADTRHD\" => 186.99,\n    \"PGK\" => 57.64,\n    \"LDH_D\" => 31.11,\n    \"ME1\" => 487.01,\n    \"PIt2r\" => 233.86,\n    \"ATPS4r\" => 71.42,\n    \"GLCpts\" => 233.90,\n    \"GLUDy\" => 105.32,\n    \"CYTBD\" => 153.18,\n    \"FUMt2_2\" => 234.37,\n    \"FRUpts2\" => 234.19,\n    \"GAPD\" => 128.76,\n    \"PPC\" => 165.52,\n    \"NADH16\" => 971.74,\n    \"PFK\" => 1000.46,\n    \"MDH\" => 25.93,\n    \"PGI\" => 468.11,\n    \"ME2\" => 443.09,\n    \"GND\" => 240.12,\n    \"SUCCt2_2\" => 234.18,\n    \"GLUN\" => 44.76,\n    \"ADK1\" => 111.64,\n    \"SUCDi\" => 680.31,\n    \"ENO\" => 209.35,\n    \"MALS\" => 252.75,\n    \"GLUt2r\" => 234.22,\n    \"PPS\" => 706.14,\n    \"FUM\" => 1576.83,\n)","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"</details>","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"We have these here:","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"ecoli_core_reaction_kcats","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"Each reaction in a constraint-based model usually has gene reaction rules associated with it. These typically take the form of, possibly multiple, isozymes that can catalyze a reaction. A turnover number needs to be assigned to each isozyme, as shown below.","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"reaction_isozymes = Dict{String,Dict{String,Isozyme}}() # a mapping from reaction IDs to isozyme IDs to isozyme structs.\nfor rid in A.reactions(model)\n    grrs = A.reaction_gene_association_dnf(model, rid)\n    isnothing(grrs) && continue # skip if no grr available\n    haskey(ecoli_core_reaction_kcats, rid) || continue # skip if no kcat data available\n    for (i, grr) in enumerate(grrs)\n        d = get!(reaction_isozymes, rid, Dict{String,Isozyme}())\n        d[\"isozyme_\"*string(i)] = Isozyme( # each isozyme gets a unique name\n            gene_product_stoichiometry = Dict(grr .=> fill(1.0, size(grr))), # assume subunit stoichiometry of 1 for all isozymes\n            kcat_forward = ecoli_core_reaction_kcats[rid] * 3.6, # forward reaction turnover number units = 1/h\n            kcat_reverse = ecoli_core_reaction_kcats[rid] * 3.6, # reverse reaction turnover number units = 1/h\n        )\n    end\nend\n\n#!!! warning \"Turnover number units\"","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"Take care with the units of the turnover numbers. In literature they are usually reported in 1/s. However, flux units are typically mmol/gDW/h, suggesting that you should rescale the turnover numbers to 1/h if you want to use the conventional flux units.","category":"page"},{"location":"examples/05-enzyme-constrained-models/#Enzyme-molar-masses","page":"Enzyme constrained models","title":"Enzyme molar masses","text":"","category":"section"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"We also require the mass of each enzyme, to properly weight the contribution of each flux/isozyme in the capacity bound(s). These data can typically be found in uniprot.","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"<details><summary><strong>Gene product masses</strong></summary>","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"This data is downloaded from Uniprot for E. coli K12, gene mass in kDa. To obtain these data yourself, go to Uniprot and search using these terms: reviewed:yes AND organism:\"Escherichia coli (strain K12) [83333]\".","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"const ecoli_core_gene_product_masses = Dict(\n    \"b4301\" => 23.214,\n    \"b1602\" => 48.723,\n    \"b4154\" => 65.972,\n    \"b3236\" => 32.337,\n    \"b1621\" => 56.627,\n    \"b1779\" => 35.532,\n    \"b3951\" => 85.96,\n    \"b1676\" => 50.729,\n    \"b3114\" => 85.936,\n    \"b1241\" => 96.127,\n    \"b2276\" => 52.044,\n    \"b1761\" => 48.581,\n    \"b3925\" => 35.852,\n    \"b3493\" => 53.389,\n    \"b3733\" => 31.577,\n    \"b2926\" => 41.118,\n    \"b0979\" => 42.424,\n    \"b4015\" => 47.522,\n    \"b2296\" => 43.29,\n    \"b4232\" => 36.834,\n    \"b3732\" => 50.325,\n    \"b2282\" => 36.219,\n    \"b2283\" => 100.299,\n    \"b0451\" => 44.515,\n    \"b2463\" => 82.417,\n    \"b0734\" => 42.453,\n    \"b3738\" => 30.303,\n    \"b3386\" => 24.554,\n    \"b3603\" => 59.168,\n    \"b2416\" => 63.562,\n    \"b0729\" => 29.777,\n    \"b0767\" => 36.308,\n    \"b3734\" => 55.222,\n    \"b4122\" => 60.105,\n    \"b2987\" => 53.809,\n    \"b2579\" => 14.284,\n    \"b0809\" => 26.731,\n    \"b1524\" => 33.516,\n    \"b3612\" => 56.194,\n    \"b3735\" => 19.332,\n    \"b3731\" => 15.068,\n    \"b1817\" => 35.048,\n    \"b1603\" => 54.623,\n    \"b1773\" => 30.81,\n    \"b4090\" => 16.073,\n    \"b0114\" => 99.668,\n    \"b3962\" => 51.56,\n    \"b2464\" => 35.659,\n    \"b2976\" => 80.489,\n    \"b1818\" => 27.636,\n    \"b2285\" => 18.59,\n    \"b1702\" => 87.435,\n    \"b1849\" => 42.434,\n    \"b1812\" => 50.97,\n    \"b0902\" => 28.204,\n    \"b3403\" => 59.643,\n    \"b1612\" => 60.299,\n    \"b1854\" => 51.357,\n    \"b0811\" => 27.19,\n    \"b0721\" => 14.299,\n    \"b2914\" => 22.86,\n    \"b1297\" => 53.177,\n    \"b0723\" => 64.422,\n    \"b3919\" => 26.972,\n    \"b3115\" => 43.384,\n    \"b4077\" => 47.159,\n    \"b3528\" => 45.436,\n    \"b0351\" => 33.442,\n    \"b2029\" => 51.481,\n    \"b1819\" => 30.955,\n    \"b0728\" => 41.393,\n    \"b2935\" => 72.212,\n    \"b2415\" => 9.119,\n    \"b0727\" => 44.011,\n    \"b0116\" => 50.688,\n    \"b0485\" => 32.903,\n    \"b3736\" => 17.264,\n    \"b0008\" => 35.219,\n    \"b3212\" => 163.297,\n    \"b3870\" => 51.904,\n    \"b4014\" => 60.274,\n    \"b2280\" => 19.875,\n    \"b2133\" => 64.612,\n    \"b2278\" => 66.438,\n    \"b0118\" => 93.498,\n    \"b2288\" => 16.457,\n    \"b3739\" => 13.632,\n    \"b3916\" => 34.842,\n    \"b3952\" => 32.43,\n    \"b2925\" => 39.147,\n    \"b2465\" => 73.043,\n    \"b2297\" => 77.172,\n    \"b2417\" => 18.251,\n    \"b4395\" => 24.065,\n    \"b3956\" => 99.063,\n    \"b0722\" => 12.868,\n    \"b2779\" => 45.655,\n    \"b0115\" => 66.096,\n    \"b0733\" => 58.205,\n    \"b1478\" => 35.38,\n    \"b2492\" => 30.565,\n    \"b0724\" => 26.77,\n    \"b0755\" => 28.556,\n    \"b1136\" => 45.757,\n    \"b2286\" => 68.236,\n    \"b0978\" => 57.92,\n    \"b1852\" => 55.704,\n    \"b2281\" => 20.538,\n    \"b2587\" => 47.052,\n    \"b2458\" => 36.067,\n    \"b0904\" => 30.991,\n    \"b1101\" => 50.677,\n    \"b0875\" => 23.703,\n    \"b3213\" => 52.015,\n    \"b2975\" => 58.92,\n    \"b0720\" => 48.015,\n    \"b0903\" => 85.357,\n    \"b1723\" => 32.456,\n    \"b2097\" => 38.109,\n    \"b3737\" => 8.256,\n    \"b0810\" => 24.364,\n    \"b4025\" => 61.53,\n    \"b1380\" => 36.535,\n    \"b0356\" => 39.359,\n    \"b2277\" => 56.525,\n    \"b1276\" => 97.677,\n    \"b4152\" => 15.015,\n    \"b1479\" => 63.197,\n    \"b4153\" => 27.123,\n    \"b4151\" => 13.107,\n    \"b2287\" => 25.056,\n    \"b0474\" => 23.586,\n    \"b2284\" => 49.292,\n    \"b1611\" => 50.489,\n    \"b0726\" => 105.062,\n    \"b2279\" => 10.845,\n    \"s0001\" => 0.0,\n)","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"</details>","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"We have the molar masses here:","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"ecoli_core_gene_product_masses","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"warning: Molar mass units\n","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"Take care with the units of the molar masses. In literature they are usually reported in Da or kDa (g/mol). However, as noted above, flux units are typically mmol/gDW/h. Since the enzyme kinetic equation is v = k * e, where k is the turnover number, it suggests that the enzyme variable will have units of mmol/gDW. The molar masses come into play when setting the capacity limitations, e.g. usually a sum over all enzymes weighted by their molar masses: e * mm. Thus, if your capacity limitation has units of g/gDW, then the molar masses must have units of g/mmol (= kDa).","category":"page"},{"location":"examples/05-enzyme-constrained-models/#Capacity-limitation","page":"Enzyme constrained models","title":"Capacity limitation","text":"","category":"section"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"The capacity limitation usually denotes an upper bound of protein available to the cell.","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"total_enzyme_capacity = 50.0 # mg of enzyme/gDW","category":"page"},{"location":"examples/05-enzyme-constrained-models/#Running-a-basic-enzyme-constrained-model","page":"Enzyme constrained models","title":"Running a basic enzyme constrained model","text":"","category":"section"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"With all the parameters specified, we can directly use the enzyme constrained convenience function to run enzyme constrained FBA in one shot:","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"ec_solution = enzyme_constrained_flux_balance_analysis(\n    model;\n    reaction_isozymes,\n    gene_product_molar_masses = ecoli_core_gene_product_masses,\n    capacity = total_enzyme_capacity,\n    optimizer = GLPK.Optimizer,\n)","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"","category":"page"},{"location":"examples/05-enzyme-constrained-models/","page":"Enzyme constrained models","title":"Enzyme constrained models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#API-reference","page":"Reference","title":"API reference","text":"","category":"section"},{"location":"reference/#Helper-types","page":"Reference","title":"Helper types","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [COBREXA]\nPages = [\"src/types.jl\"]","category":"page"},{"location":"reference/#COBREXA.Maybe","page":"Reference","title":"COBREXA.Maybe","text":"Maybe{X}\n\nType of optional values.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Model-loading-and-saving","page":"Reference","title":"Model loading and saving","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [COBREXA]\nPages = [\"src/io.jl\"]","category":"page"},{"location":"reference/#COBREXA.download_model-Tuple","page":"Reference","title":"COBREXA.download_model","text":"download_model(args...; kwargs...) -> Any\n\n\nSafely download a model with a known hash. All arguments are forwarded to AbstractFBCModels.download_data_file – see the documentation in the AbstractFBCModels package for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#COBREXA.load_model-Tuple{String}","page":"Reference","title":"COBREXA.load_model","text":"load_model(path::String) -> Any\n\n\nLoad a FBC model representation while guessing the correct model type. Uses AbstractFBCModels.load.\n\nThis overload almost always involves a search over types; do not use it in environments where performance is critical.\n\n\n\n\n\n","category":"method"},{"location":"reference/#COBREXA.load_model-Union{Tuple{T}, Tuple{Type{T}, String}} where T<:AbstractFBCModels.AbstractFBCModel","page":"Reference","title":"COBREXA.load_model","text":"load_model(\n    model_type::Type{T<:AbstractFBCModels.AbstractFBCModel},\n    path::String\n) -> Any\n\n\nLoad a FBC model representation. Uses AbstractFBCModels.load.\n\n\n\n\n\n","category":"method"},{"location":"reference/#COBREXA.save_model-Union{Tuple{T}, Tuple{T, String}} where T<:AbstractFBCModels.AbstractFBCModel","page":"Reference","title":"COBREXA.save_model","text":"save_model(\n    model::AbstractFBCModels.AbstractFBCModel,\n    path::String\n)\n\n\nSave a FBC model representation. Uses AbstractFBCModels.save.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Solver-interface","page":"Reference","title":"Solver interface","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [COBREXA]\nPages = [\"src/solver.jl\"]","category":"page"},{"location":"reference/#COBREXA.Feasible","page":"Reference","title":"COBREXA.Feasible","text":"Maximal\n\nObjective sense for finding the any feasible value of the objective.\n\nSame as JuMP.FEASIBILITY_SENSE.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#COBREXA.Maximal","page":"Reference","title":"COBREXA.Maximal","text":"Maximal\n\nObjective sense for finding the maximal value of the objective.\n\nSame as JuMP.MAX_SENSE.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#COBREXA.Minimal","page":"Reference","title":"COBREXA.Minimal","text":"Minimal\n\nObjective sense for finding the minimal value of the objective.\n\nSame as JuMP.MIN_SENSE.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#COBREXA.Switch","page":"Reference","title":"COBREXA.Switch","text":"mutable struct Switch <: ConstraintTrees.Bound\n\nRepresentation of a \"binary switch\" bound for ConstraintTrees. The value is constrained to be either the value of field a or of field b; both fields are Float64s. Upon translation to JuMP, the switches create an extra boolean variable, and the value is constrained to equal a + boolean_var * (b-a).\n\nSwitches can be offset by adding real numbers, negated, and multiplied and divided by scalar constraints. For optimizing some special cases, multiplying by exact zero returns an equality bound to zero.\n\nFields\n\na::Float64: One choice\nb::Float64: The other choice\n\n\n\n\n\n","category":"type"},{"location":"reference/#COBREXA.is_solved-Tuple{JuMP.Model}","page":"Reference","title":"COBREXA.is_solved","text":"is_solved(opt_model::JuMP.Model) -> Bool\n\n\ntrue if opt_model solved successfully (solution is optimal or locally optimal). false if any other termination status is reached.\n\n\n\n\n\n","category":"method"},{"location":"reference/#COBREXA.optimization_model-Tuple{Union{ConstraintTrees.Constraint, ConstraintTrees.Tree{ConstraintTrees.Constraint}}}","page":"Reference","title":"COBREXA.optimization_model","text":"optimization_model(\n    cs::Union{ConstraintTrees.Constraint, ConstraintTrees.Tree{ConstraintTrees.Constraint}};\n    objective,\n    optimizer,\n    sense\n)\n\n\nConstruct a JuMP Model that describes the precise constraint system into the JuMP Model created for solving in optimizer, with a given optional objective and optimization sense chosen from Maximal, Minimal and Feasible.\n\n\n\n\n\n","category":"method"},{"location":"reference/#COBREXA.optimized_model-Tuple{Any}","page":"Reference","title":"COBREXA.optimized_model","text":"optimized_model(om; output)\n\n\nLike optimized_values, but works directly with a given JuMP model om without applying any settings or creating the optimization model.\n\nTo run the process manually, you can use optimization_model to convert the constraints into a suitable JuMP optimization model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Constraint-system-building","page":"Reference","title":"Constraint system building","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [COBREXA]\nPages = [\"src/builders/core.jl\"]","category":"page"},{"location":"reference/#Genetic-constraints","page":"Reference","title":"Genetic constraints","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [COBREXA]\nPages = [\"src/builders/genes.jl\"]","category":"page"},{"location":"reference/#Objective-function-helpers","page":"Reference","title":"Objective function helpers","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [COBREXA]\nPages = [\"src/builders/objectives.jl\"]","category":"page"},{"location":"reference/#COBREXA.squared_sum_error_value-Tuple{ConstraintTrees.Tree{ConstraintTrees.Constraint}, Any}","page":"Reference","title":"COBREXA.squared_sum_error_value","text":"squared_sum_error_value(\n    constraints::ConstraintTrees.Tree{ConstraintTrees.Constraint},\n    target\n) -> Any\n\n\nConstruct a ConstraintTrees.Value out of squared error (in the RMSE-like squared-error sense) between the values in the constraint tree and the reference target.\n\ntarget is a function that takes a symbol (key) and returns either a Float64 reference value, or nothing if the error of given key should not be considered.\n\n\n\n\n\n","category":"method"},{"location":"reference/#COBREXA.squared_sum_value-Tuple{ConstraintTrees.Tree{ConstraintTrees.Constraint}}","page":"Reference","title":"COBREXA.squared_sum_value","text":"squared_sum_value(\n    x::ConstraintTrees.Tree{ConstraintTrees.Constraint}\n) -> Union{ConstraintTrees.LinearValue, ConstraintTrees.QuadraticValue}\n\n\nConstruct a ConstraintTrees.Value out of squared sum of all values directly present in a given constraint tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#COBREXA.sum_value-Tuple","page":"Reference","title":"COBREXA.sum_value","text":"sum_value(x...) -> Any\n\n\nConstruct a ConstraintTrees.Value out of a sum of all values directly present in a given constraint tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Bounds-and-tolerances-helpers","page":"Reference","title":"Bounds&tolerances helpers","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [COBREXA]\nPages = [\"src/misc/bounds.jl\"]","category":"page"},{"location":"reference/#COBREXA.absolute_tolerance_bound-Tuple{Any}","page":"Reference","title":"COBREXA.absolute_tolerance_bound","text":"absolute_tolerance_bound(tolerance) -> COBREXA.var\"#191#192\"\n\n\nMake a function that returns absolute tolerance bounds, i.e. value - tolerance and value + tolerance in a tuple, in the increasing order.\n\n\n\n\n\n","category":"method"},{"location":"reference/#COBREXA.relative_tolerance_bound-Tuple{Any}","page":"Reference","title":"COBREXA.relative_tolerance_bound","text":"relative_tolerance_bound(tolerance) -> COBREXA.var\"#193#194\"\n\n\nMake a function that returns relative tolerance bounds, i.e. value / tolerance and value * tolerance in a tuple, in the increasing order.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Analysis-functions","page":"Reference","title":"Analysis functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [COBREXA]\nPages = [\"src/analysis/flux_balance.jl\", \"src/analysis/parsimonious_flux_balance.jl\"]","category":"page"},{"location":"reference/#Analysis-modifications","page":"Reference","title":"Analysis modifications","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [COBREXA]\nPages = [\"src/analysis/modifications.jl\"]","category":"page"},{"location":"reference/#Distributed-analysis","page":"Reference","title":"Distributed analysis","text":"","category":"section"},{"location":"distributed/2_parallel/#Local-parallel-processing","page":"Local parallel processing","title":"Local parallel processing","text":"","category":"section"},{"location":"distributed/2_parallel/","page":"Local parallel processing","title":"Local parallel processing","text":"To run an analysis in parallel, you first need to load the Distributed package and add a few worker processes. For example, you may start 5 local processes (that may utilize 5 CPUs) like this:","category":"page"},{"location":"distributed/2_parallel/","page":"Local parallel processing","title":"Local parallel processing","text":"using Distributed\naddprocs(5)","category":"page"},{"location":"distributed/2_parallel/","page":"Local parallel processing","title":"Local parallel processing","text":"note: `Distributed.jl` installation\nDistributed.jl usually comes pre-installed with Julia distribution, but you may still need to \"enable\" it by typing ] add Distributed.","category":"page"},{"location":"distributed/2_parallel/","page":"Local parallel processing","title":"Local parallel processing","text":"You may check that the workers are really there, using workers(). In this case, it should give you a vector of worker IDs, very likely equal to [2,3,4,5,6].","category":"page"},{"location":"distributed/2_parallel/","page":"Local parallel processing","title":"Local parallel processing","text":"Each of the processes contains a self-sufficient image of Julia that can act independently; in turn the additional processes also consume some memory. Each process with loaded COBREXA.jl and a simple solver such as GLPK may consume around 500MB of RAM, which should be taken into account when planning the analysis scale.","category":"page"},{"location":"distributed/2_parallel/","page":"Local parallel processing","title":"Local parallel processing","text":"Packages (COBREXA and your selected solver) must be loaded at all processes, which you can ensure using the \"everywhere\" macro:","category":"page"},{"location":"distributed/2_parallel/","page":"Local parallel processing","title":"Local parallel processing","text":"@everywhere using COBREXA, GLPK","category":"page"},{"location":"distributed/2_parallel/","page":"Local parallel processing","title":"Local parallel processing","text":"Utilizing the prepared worker processes is then straightforward: You pass the list of workers to the selected analysis function using the workers keyword argument, and the parallel processing is automatically orchestrated for you.","category":"page"},{"location":"distributed/2_parallel/","page":"Local parallel processing","title":"Local parallel processing","text":"model = load_model(\"e_coli_core.xml\")\nresult = flux_variability_analysis(model, GLPK.Optimizer; workers=workers())","category":"page"},{"location":"distributed/#Parallel,-distributed-and-HPC-processing","page":"Contents","title":"Parallel, distributed and HPC processing","text":"","category":"section"},{"location":"distributed/","page":"Contents","title":"Contents","text":"Pages = filter(x -> endswith(x, \".md\"), readdir(\"distributed\", join=true))\nDepth = 2","category":"page"},{"location":"reference/builders/#Constraint-system-building","page":"-","title":"Constraint system building","text":"","category":"section"},{"location":"reference/builders/","page":"-","title":"-","text":"Modules = [COBREXA]\nPages = [\"src/builders/core.jl\"]","category":"page"},{"location":"reference/builders/#Genetic-constraints","page":"-","title":"Genetic constraints","text":"","category":"section"},{"location":"reference/builders/","page":"-","title":"-","text":"Modules = [COBREXA]\nPages = [\"src/builders/genes.jl\"]","category":"page"},{"location":"reference/builders/#Objective-function-helpers","page":"-","title":"Objective function helpers","text":"","category":"section"},{"location":"reference/builders/","page":"-","title":"-","text":"Modules = [COBREXA]\nPages = [\"src/builders/objectives.jl\"]","category":"page"},{"location":"distributed/1_functions/#Parallel-processing-overview","page":"Parallel processing overview","title":"Parallel processing overview","text":"","category":"section"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"Distributed processing in Julia is represented mainly by the package Distributed.jl.","category":"page"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"COBREXA.jl is able to utilize this existing system to almost transparently run the large parallelizable analyses on multiple CPU cores and multiple computers connected through the network. Ultimately, the approach scales to thousands of computing nodes in large HPC facilities.","category":"page"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"You may run your analyses in parallel to gain speed-ups. The usual workflow in COBREXA.jl is quite straightforward:","category":"page"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"Import the Distributed package and add worker processes, e.g. using addprocs.\nPick an analysis function that can be parallelized (such as screen or flux_variability_analysis) and prepare it to work on your data.\nPass the desired set of worker IDs to the function using workers= argument, in the simplest form using e.g. screen(...,  workers=workers()).\nWorker communication will be managed automatically, and you will get results \"as usual\".","category":"page"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"Specific documentation is available about running parallel analysis locally and running distributed analysis in HPC clusters.","category":"page"},{"location":"distributed/1_functions/#Functions-that-support-parallelization","page":"Parallel processing overview","title":"Functions that support parallelization","text":"","category":"section"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"As of COBREXA 1.3, the list of functions that accept the worker argument is as follows:","category":"page"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"affine_hit_and_run sampling, together with warmup_from_variability\nflux_variability_analysis\nmax_min_driving_force\nobjective_envelope\nscreen\nscreen_optmodel_modifications","category":"page"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"Notably, the screening functions are reused to run many other kinds of analyses which, in turn, inherit the parallelizability. This includes a wide range of functionality, including analyses such as:","category":"page"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"single and multiple gene deletions (and other genetic modifications),\nmodifications of the reaction spectrum (e.g., disabling reactions)\nadvanced envelope-scanning analyses,\ngrowth media exploration (e.g., metabolite depletion)","category":"page"},{"location":"distributed/1_functions/#Mitigating-parallel-inefficiencies","page":"Parallel processing overview","title":"Mitigating parallel inefficiencies","text":"","category":"section"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"Ideally, the speedup gained by parallel processing should be proportional to the amount of hardware you add as the workers. You should be aware of factors that reduce the parallel efficiency, which can be summarized as follows:","category":"page"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"Parallelization within single runs of the linear solver is typically not supported (and if it is, it may be inefficient for usual problem sizes). You usually want to parallelize the analyzes that comprise multiple independent runs of the solvers.\nSome analysis function, such as flux_variability_analysis, have serial parts that can not be parallelized by default. Usually, you may avoid the inefficiency by precomputing the serial analysis parts without involving the cluster of the workers.\nRequirements for frequent worker communication may vastly reduce the efficiency of parallel processing; typically this happens if the time required for individual analysis steps is smaller than the network round-trip-time to the worker processes. Do not use unnecessary parallelization for small tasks.\nTransferring large amounts of data among workers may hamper parallel efficiency. Use the system of model variants to avoid transferring many similar models to the workers, and model serialization functionality to quickly distribute share large models to the workers.","category":"page"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"note: Cost of the distribution and parallelization overhead\nBefore allocating extra resources into the distributed execution, always check that your tasks are properly parallelizable and sufficiently large to saturate your computation resources, so that the invested energy is not wasted. Amdahl's and Gustafson's laws can give you a better overview of the sources and consequences of the parallelization inefficiencies and the costs of the resulting overhead.","category":"page"},{"location":"examples/#Examples","page":"Contents","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Contents","title":"Contents","text":"Pages = filter(x -> endswith(x, \".md\"), readdir(\"examples\", join=true))\nDepth = 2","category":"page"},{"location":"#COBREXA.jl","page":"Home","title":"COBREXA.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [COBREXA]\nPages = [\"src/COBREXA.jl\"]","category":"page"},{"location":"#COBREXA.COBREXA","page":"Home","title":"COBREXA.COBREXA","text":"module COBREXA\n\nCOnstraint Based Reconstruction and EXascale Analysis. COBREXA provides functions for construction, modification, simulation and analysis of constraint-based metabolic models that follows the COBRA methodology.\n\nCOBREXA is built as a front-end for the combination of AbstractFBCModels.jl (provides the model I/O), ConstraintTrees.jl (provides the constraint system organization), Distributed.jl (provides HPC execution capability), and JuMP.jl (provides the solvers).\n\nSee the online documentation for a complete description of functionality aided by copy-pastable examples.\n\nTo start quickly, load your favorite JuMP-compatible solver, use load_model to read a metabolic model from the disk, and solve it with flux_balance.\n\n\n\n\n\n","category":"module"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"EditURL = \"02b-model-modifications.jl\"","category":"page"},{"location":"examples/02b-model-modifications/#Making-adjustments-to-the-model","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"","category":"section"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"Typically, we do not need to solve the models as they come from the authors (someone else already did that!), but we want to perform various perturbations in the model structure and conditions, and explore how the model behaves in the changed conditions.","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"With COBREXA, there are 2 different approaches that one can take:","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"We can change the model structure and use the changed metabolic model. This is better for doing simple and small but systematic modifications, such as removing metabolites, adding reactions, etc.\nWe can intercept the pipeline that converts the metabolic model to constraints and then to the optimizer representation, and make small modifications along that way. This is better for various technical model adjustments, such as using combined objectives or adding reaction-coupling constraints.","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"Here we demonstrate the first, \"modelling\" approach. The main advantage of that approach is that the modified model is still a FBC model, and you can export, save and share it via the AbstractFBCModels interace. The main disadvantage is that the \"common\" FBC model interface does not easily express various complicated constructions (communities, reaction coupling, enzyme constraints, etc.) – see the example about modifying the constraints for a closer look on how to modify even such complex constructions.","category":"page"},{"location":"examples/02b-model-modifications/#Getting-the-base-model","page":"Making adjustments to the model","title":"Getting the base model","text":"","category":"section"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"using COBREXA\n\ndownload_model(\n    \"http://bigg.ucsd.edu/static/models/e_coli_core.json\",\n    \"e_coli_core.json\",\n    \"7bedec10576cfe935b19218dc881f3fb14f890a1871448fc19a9b4ee15b448d8\",\n)\n\nimport JSONFBCModels","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"For applying the modifications, we will use the canonical model as exported from package AbstractFBCModels. There are other possibilities, but the canonical one is easiest to use for common purposes.","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"import AbstractFBCModels.CanonicalModel as CM","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"We can now load the model:","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"model = convert(CM.Model, load_model(\"e_coli_core.json\"))","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"The canonical model is quite easy to work with, made basically of the most accessible Julia structures possible. For example, you can observe a reaction as such:","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"model.reactions[\"PFK\"]","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"model.reactions[\"CS\"].stoichiometry","category":"page"},{"location":"examples/02b-model-modifications/#Running-FBA-on-modified-models","page":"Making adjustments to the model","title":"Running FBA on modified models","text":"","category":"section"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"Since the canonical model is completely mutable, you can change it in any way you like and feed it directly into flux_balance_analysis. Let's first find a \"original\" solution, so that we have a base solution for comparing:","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"import GLPK\n\nbase_solution = flux_balance_analysis(model, GLPK.Optimizer)\nbase_solution.objective","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"Now, for example, we can limit the intake of glucose by the model:","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"model.reactions[\"EX_glc__D_e\"]","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"Since the original intake limit is 10 units, let's try limiting that to 5:","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"model.reactions[\"EX_glc__D_e\"].lower_bound = -5.0","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"...and solve the modified model:","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"low_glucose_solution = flux_balance_analysis(model, GLPK.Optimizer)\nlow_glucose_solution.objective","category":"page"},{"location":"examples/02b-model-modifications/#Preventing-reference-based-sharing-problems-with-deepcopy","page":"Making adjustments to the model","title":"Preventing reference-based sharing problems with deepcopy","text":"","category":"section"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"People often want to try different perturbations with a single base model. It would therefore look feasible to save retain the \"unmodified\" model in a single variable, and make copies of that with the modifications applied. Let's observe what happens:","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"base_model = convert(CM.Model, load_model(\"e_coli_core.json\")) # load the base\n\nmodified_model = base_model # copy for modification\n\nmodified_model.reactions[\"EX_glc__D_e\"].lower_bound = -123.0 # modify the glucose intake limit","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"Surprisingly, the base model got modified too!","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"base_model.reactions[\"EX_glc__D_e\"]","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"This is because Julia uses reference-based sharing whenever anything mutable is copied using the = operator. While this is extremely useful in many scenarios for data processing efficiency and computational speed, it unfortunately breaks this simple use-case.","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"To fix the situation, you should always ensure to make an actual copy of the model data by either carefully copying the changed parts with copy(), or simply by copying the whole model structure as is with deepcopy(). Let's try again:","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"base_model = convert(CM.Model, load_model(\"e_coli_core.json\"))\nmodified_model = deepcopy(base_model) # this forces an actual copy of the data\nmodified_model.reactions[\"EX_glc__D_e\"].lower_bound = -123.0","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"With deepcopy, the result works as intended:","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"(\n    modified_model.reactions[\"EX_glc__D_e\"].lower_bound,\n    base_model.reactions[\"EX_glc__D_e\"].lower_bound,\n)","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"danger: Avoid overwriting base models when using in-place modifications\nWhenever you are changing a copy of the model, make sure that you are not changing it by a reference. Always use some copy mechanism such as copy or deepcopy to prevent the default reference-based sharing.","category":"page"},{"location":"examples/02b-model-modifications/#Observing-the-differences","page":"Making adjustments to the model","title":"Observing the differences","text":"","category":"section"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"We already have a base_solution and low_glucose_solution from above. What is the easiest way to see what has changed? We can quite easily compute squared distance between all dictionary entries using Julia function for merging dictionaries (called mergewith).","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"With that, we can extract the plain difference in fluxes:","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"flux_differences = mergewith(-, base_solution.fluxes, low_glucose_solution.fluxes)","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"...and see what were the biggest directional differences:","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"sort(collect(flux_differences), by = last)","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"...or compute the squared distance, to see the \"absolute\" changes:","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"flux_changes =\n    mergewith((x, y) -> (x - y)^2, base_solution.fluxes, low_glucose_solution.fluxes)","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"...and again see what changed most:","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"sort(collect(flux_changes), by = last)","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"tip: For realistic comparisons always use a uniquely defined flux solution\nSince the usual flux balance allows a lot of freedom in the \"solved\" flux and the only value that is \"reproducible\" by the analysis is the objective, one should never compare the flux distributions directly. Typically, that may result in false-positive (and sometimes false-negative) differences. Use e.g. parsimonious FBA to obtain uniquely determined and safely comparable flux solutions.","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"","category":"page"},{"location":"examples/02b-model-modifications/","page":"Making adjustments to the model","title":"Making adjustments to the model","text":"This page was generated using Literate.jl.","category":"page"}]
}
