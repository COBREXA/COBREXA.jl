<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gap filling · COBREXA.jl</title><meta name="title" content="Gap filling · COBREXA.jl"/><meta property="og:title" content="Gap filling · COBREXA.jl"/><meta property="twitter:title" content="Gap filling · COBREXA.jl"/><meta name="description" content="Documentation for COBREXA.jl."/><meta property="og:description" content="Documentation for COBREXA.jl."/><meta property="twitter:description" content="Documentation for COBREXA.jl."/><meta property="og:url" content="https://cobrexa.github.io/COBREXA.jl/stable/examples/05g-gapfilling/"/><meta property="twitter:url" content="https://cobrexa.github.io/COBREXA.jl/stable/examples/05g-gapfilling/"/><link rel="canonical" href="https://cobrexa.github.io/COBREXA.jl/stable/examples/05g-gapfilling/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="COBREXA.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="COBREXA.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">COBREXA.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../">Contents</a></li><li><a class="tocitem" href="../01-loading-and-saving/">Loading and saving models</a></li><li><a class="tocitem" href="../02a-flux-balance-analysis/">Flux balance analysis (FBA)</a></li><li><a class="tocitem" href="../02b-optimizer-parameters/">Changing optimizer parameters</a></li><li><a class="tocitem" href="../02c-model-modifications/">Making adjustments to the model</a></li><li><a class="tocitem" href="../02d-constraint-modifications/">Making adjustments to the constraint system</a></li><li><a class="tocitem" href="../03a-flux-variability-analysis/">Flux variability analysis (FVA)</a></li><li><a class="tocitem" href="../03b-parsimonious-flux-balance/">Parsimonious flux balance analysis</a></li><li><a class="tocitem" href="../03c-envelopes/">Production envelopes</a></li><li><a class="tocitem" href="../03d-unidirectional/">Split unidirectional reactions in models</a></li><li><a class="tocitem" href="../04-community-models/">Community FBA models</a></li><li><a class="tocitem" href="../05a-minimization-of-metabolic-adjustment/">Minimization of metabolic adjustment analysis</a></li><li><a class="tocitem" href="../05b-enzyme-constrained-models/">Enzyme constrained models</a></li><li><a class="tocitem" href="../05c-mmdf/">Thermodynamic models</a></li><li><a class="tocitem" href="../05d-loopless-models/">Loopless flux balance analysis (ll-FBA)</a></li><li><a class="tocitem" href="../05e-knockouts/">Gene knockouts</a></li><li><a class="tocitem" href="../05f-cyclefree/">CycleFreeFlux</a></li><li class="is-active"><a class="tocitem" href>Gap filling</a><ul class="internal"><li><a class="tocitem" href="#Making-the-model-feasible-with-a-minimal-set-of-reactions"><span>Making the model feasible with a minimal set of reactions</span></a></li><li><a class="tocitem" href="#Model-debugging:-which-metabolite-is-missing?"><span>Model debugging: which metabolite is missing?</span></a></li></ul></li><li><a class="tocitem" href="../06a-sampling/">Flux sampling</a></li><li><a class="tocitem" href="../06b-screening/">Screening through many model variants</a></li></ul></li><li><a class="tocitem" href="../../structure/">Core concepts and structure</a></li><li><span class="tocitem">Parallel, distributed and HPC processing</span><ul><li><a class="tocitem" href="../../distributed/">Contents</a></li><li><a class="tocitem" href="../../distributed/1_functions/">Parallel processing overview</a></li><li><a class="tocitem" href="../../distributed/2_parallel/">Local parallel processing</a></li><li><a class="tocitem" href="../../distributed/3_slurm/">Working in a HPC environment</a></li></ul></li><li><span class="tocitem">API reference</span><ul><li><a class="tocitem" href="../../reference/">Contents</a></li><li><a class="tocitem" href="../../reference/analysis/">Specialized analysis functions</a></li><li><a class="tocitem" href="../../reference/builders/">Constraint system builders</a></li><li><a class="tocitem" href="../../reference/core/">Core functionality</a></li><li><a class="tocitem" href="../../reference/frontend/">Front-end user interface</a></li><li><a class="tocitem" href="../../reference/misc/">Miscellaneous functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Gap filling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Gap filling</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/COBREXA/COBREXA.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/COBREXA/COBREXA.jl/blob/master/docs/src/examples/05g-gapfilling.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Gap-filling"><a class="docs-heading-anchor" href="#Gap-filling">Gap filling</a><a id="Gap-filling-1"></a><a class="docs-heading-anchor-permalink" href="#Gap-filling" title="Permalink"></a></h1><p>Gapfilling is used to find easiest additions to the models that would make them feasible and capable of growth.</p><p>Typically, an infeasible model (&quot;with gaps&quot;) is used together with an universal model (which contains &quot;everything&quot;), and the algorithm attempts to find the minimal amount of reactions from the universal model that make the gappy model happy. In turn, the gapfilling optimization problem becomes a MILP.</p><p>Gapfilling is sometimes used to produce &quot;viable&quot; genome-scale reconstructions from partial ones, but without additional manual intervention the gapfilling results are almost never biologically valid. A good use of gapfilling is to find problems in a model that cause infeasibility as follows: First the modeller makes a set of (unrealistic) universal reactions that supply or remove metabolites, and after gapfilling, metabolites that had to be supplied or removed to make the model feasible mark possible problems, thus guiding the modeller towards correct solution.</p><p>We will use a partially crippled <em>E. coli</em> toy model and see the minimal amount of reactions that may save it.</p><pre><code class="language-julia hljs">using COBREXA

download_model(
    &quot;http://bigg.ucsd.edu/static/models/e_coli_core.json&quot;,
    &quot;e_coli_core.json&quot;,
    &quot;7bedec10576cfe935b19218dc881f3fb14f890a1871448fc19a9b4ee15b448d8&quot;,
)

import JSONFBCModels, HiGHS
model = load_model(&quot;e_coli_core.json&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">JSONFBCModels.JSONFBCModel(#= 95 reactions, 72 metabolites =#)</code></pre><p>First, let&#39;s produce an infeasible model:</p><pre><code class="language-julia hljs">import AbstractFBCModels.CanonicalModel as CM
infeasible_model = convert(CM.Model, model)

for rxn in [&quot;TALA&quot;, &quot;PDH&quot;, &quot;PGI&quot;, &quot;PYK&quot;]
    infeasible_model.reactions[rxn].lower_bound = 0.0
    infeasible_model.reactions[rxn].upper_bound = 0.0
end</code></pre><p>After removing the above reactions, the model will fail to solve:</p><pre><code class="language-julia hljs">flux_balance_analysis(infeasible_model, optimizer = HiGHS.Optimizer) |&gt; println</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">nothing</code></pre><p>To avoid very subtle semantic issues, we are going to remove the ATP maintenance pseudoreaction from the universal model:</p><pre><code class="language-julia hljs">universal_model = convert(CM.Model, model)
delete!(universal_model.reactions, &quot;ATPM&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, AbstractFBCModels.CanonicalModel.Reaction} with 94 entries:
  &quot;ACALD&quot;       =&gt; Reaction(&quot;Acetaldehyde dehydrogenase (acetylating)&quot;, -1000.0…
  &quot;PTAr&quot;        =&gt; Reaction(&quot;Phosphotransacetylase&quot;, -1000.0, 1000.0, Dict(&quot;coa…
  &quot;ALCD2x&quot;      =&gt; Reaction(&quot;Alcohol dehydrogenase (ethanol)&quot;, -1000.0, 1000.0,…
  &quot;PDH&quot;         =&gt; Reaction(&quot;Pyruvate dehydrogenase&quot;, 0.0, 1000.0, Dict(&quot;coa_c&quot;…
  &quot;PYK&quot;         =&gt; Reaction(&quot;Pyruvate kinase&quot;, 0.0, 1000.0, Dict(&quot;adp_c&quot;=&gt;-1.0,…
  &quot;CO2t&quot;        =&gt; Reaction(&quot;CO2 transporter via diffusion&quot;, -1000.0, 1000.0, D…
  &quot;EX_nh4_e&quot;    =&gt; Reaction(&quot;Ammonia exchange&quot;, -1000.0, 1000.0, Dict(&quot;nh4_e&quot;=&gt;…
  &quot;MALt2_2&quot;     =&gt; Reaction(&quot;Malate transport via proton symport (2 H)&quot;, 0.0, 1…
  &quot;CS&quot;          =&gt; Reaction(&quot;Citrate synthase&quot;, 0.0, 1000.0, Dict(&quot;coa_c&quot;=&gt;1.0,…
  &quot;PGM&quot;         =&gt; Reaction(&quot;Phosphoglycerate mutase&quot;, -1000.0, 1000.0, Dict(&quot;3…
  &quot;TKT1&quot;        =&gt; Reaction(&quot;Transketolase&quot;, -1000.0, 1000.0, Dict(&quot;g3p_c&quot;=&gt;1.0…
  &quot;EX_mal__L_e&quot; =&gt; Reaction(&quot;L-Malate exchange&quot;, 0.0, 1000.0, Dict(&quot;mal__L_e&quot;=&gt;…
  &quot;ACONTa&quot;      =&gt; Reaction(&quot;Aconitase (half-reaction A, Citrate hydro-lyase)&quot;,…
  &quot;EX_pi_e&quot;     =&gt; Reaction(&quot;Phosphate exchange&quot;, -1000.0, 1000.0, Dict(&quot;pi_e&quot;=…
  &quot;GLNS&quot;        =&gt; Reaction(&quot;Glutamine synthetase&quot;, 0.0, 1000.0, Dict(&quot;adp_c&quot;=&gt;…
  &quot;ICL&quot;         =&gt; Reaction(&quot;Isocitrate lyase&quot;, 0.0, 1000.0, Dict(&quot;succ_c&quot;=&gt;1.0…
  &quot;EX_o2_e&quot;     =&gt; Reaction(&quot;O2 exchange&quot;, -1000.0, 1000.0, Dict(&quot;o2_e&quot;=&gt;-1.0),…
  &quot;FBA&quot;         =&gt; Reaction(&quot;Fructose-bisphosphate aldolase&quot;, -1000.0, 1000.0, …
  &quot;EX_gln__L_e&quot; =&gt; Reaction(&quot;L-Glutamine exchange&quot;, 0.0, 1000.0, Dict(&quot;gln__L_e…
  ⋮             =&gt; ⋮</code></pre><h2 id="Making-the-model-feasible-with-a-minimal-set-of-reactions"><a class="docs-heading-anchor" href="#Making-the-model-feasible-with-a-minimal-set-of-reactions">Making the model feasible with a minimal set of reactions</a><a id="Making-the-model-feasible-with-a-minimal-set-of-reactions-1"></a><a class="docs-heading-anchor-permalink" href="#Making-the-model-feasible-with-a-minimal-set-of-reactions" title="Permalink"></a></h2><p>Which of the reactions we have to fill back to get the model working again? First, let&#39;s run <a href="../../reference/frontend/#COBREXA.gap_filling_analysis-Tuple"><code>gap_filling_analysis</code></a> to get a solution for a system that implements the reaction patching:</p><pre><code class="language-julia hljs">x = gap_filling_analysis(
    infeasible_model,
    universal_model,
    0.05,
    optimizer = HiGHS.Optimizer,
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{Float64} with 6 elements:
  :fill_flags            =&gt; ConstraintTrees.Tree{Float64}(#= 94 elements =#)
  :n_filled              =&gt; 1.0
  :stoichiometry         =&gt; ConstraintTrees.Tree{Float64}(#= 72 elements =#)
  :system                =&gt; ConstraintTrees.Tree{Float64}(#= 3 elements =#)
  :universal_flux_bounds =&gt; ConstraintTrees.Tree{Float64}(#= 94 elements =#)
  :universal_fluxes      =&gt; ConstraintTrees.Tree{Float64}(#= 94 elements =#)</code></pre><p>The reactions that had to be re-added can be found from the <code>fill_flags</code>:</p><pre><code class="language-julia hljs">filled_reactions = [k for (k, v) in x.fill_flags if v != 0]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Symbol}:
 :TALA</code></pre><p>If we want to try to generate another solution, we have to explicitly ask the system to avoid the previous solution. That is done via setting the argument <code>known_fill</code>. We can also set the <code>max_cost</code> to avoid finding too benevolent solutions:</p><pre><code class="language-julia hljs">x2 = gap_filling_analysis(
    infeasible_model,
    universal_model,
    0.05,
    max_cost = 2.0,
    known_fills = [x.fill_flags],
    optimizer = HiGHS.Optimizer,
)

other_filled_reactions = [k for (k, v) in x2.fill_flags if v != 0]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Symbol}:
 :PGI</code></pre><div class="admonition is-warning"><header class="admonition-header">Why is the gapfilling algorithm adding seemingly unneeded reactions?</header><div class="admonition-body"><p>By default, COBREXA does not do any &quot;cleaning&quot; on the universal model; all reactions that are present in that model will be potentially utilized in the new model, and all of them will need to respect their original bounds in the universal model. That becomes an issue with <strong>reactions that are bounded to non-zero flux</strong> (such as the <code>ATPM</code> reaction in the E. coli &quot;core&quot; model) – since their flux is required to be non-zero in any feasible model solution, they will also need to be in the fill set, because otherwise their flux would be zero.</p><p>As the simplest solution, all realistic uses of gapfilling should carefully check the set of universal reactions, and ideally exclude all exchanges and pseudoreactions.</p></div></div><h2 id="Model-debugging:-which-metabolite-is-missing?"><a class="docs-heading-anchor" href="#Model-debugging:-which-metabolite-is-missing?">Model debugging: which metabolite is missing?</a><a id="Model-debugging:-which-metabolite-is-missing?-1"></a><a class="docs-heading-anchor-permalink" href="#Model-debugging:-which-metabolite-is-missing?" title="Permalink"></a></h2><p>Gap-filling is great for detecting various broken links and imbalances in metabolic models. We show how to find the metabolites are causing the imbalance for our &quot;broken&quot; E. coli model.</p><p>First, we construct a few completely unnatural reactions that create/remove the metabolites from/to nowhere:</p><pre><code class="language-julia hljs">magic_model = convert(CM.Model, model)
empty!(magic_model.genes)
empty!(magic_model.reactions)

for mid in keys(magic_model.metabolites)
    magic_model.reactions[mid] = CM.Reaction(
        lower_bound = -100.0,
        upper_bound = 100.0,
        stoichiometry = Dict(mid =&gt; 1.0),
    )
end</code></pre><p>Gapfilling now points to the metabolites that need to be somehow taken care of by the modeller in order for the model to become feasible:</p><pre><code class="language-julia hljs">xm = gap_filling_analysis(infeasible_model, magic_model, 0.05, optimizer = HiGHS.Optimizer)

blocking_metabolites = [k for (k, v) in xm.fill_flags if v != 0]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Symbol}:
 :e4p_c</code></pre><p>We can also have a look at how much of a given metabolite was used to make the model feasible again:</p><pre><code class="language-julia hljs">xm.universal_fluxes[first(blocking_metabolites)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.6866985638297876</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../05f-cyclefree/">« CycleFreeFlux</a><a class="docs-footer-nextpage" href="../06a-sampling/">Flux sampling »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 7 January 2025 09:25">Tuesday 7 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
