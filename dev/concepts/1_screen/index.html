<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Screening many model variants · COBREXA.jl</title><meta name="title" content="Screening many model variants · COBREXA.jl"/><meta property="og:title" content="Screening many model variants · COBREXA.jl"/><meta property="twitter:title" content="Screening many model variants · COBREXA.jl"/><meta name="description" content="Documentation for COBREXA.jl."/><meta property="og:description" content="Documentation for COBREXA.jl."/><meta property="twitter:description" content="Documentation for COBREXA.jl."/><meta property="og:url" content="https://cobrexa.github.io/COBREXA.jl/stable/concepts/1_screen/"/><meta property="twitter:url" content="https://cobrexa.github.io/COBREXA.jl/stable/concepts/1_screen/"/><link rel="canonical" href="https://cobrexa.github.io/COBREXA.jl/stable/concepts/1_screen/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="COBREXA.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="COBREXA.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">COBREXA.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/">Contents</a></li><li><a class="tocitem" href="../../examples/01-loading-and-saving/">Loading and saving models!</a></li><li><a class="tocitem" href="../../examples/02-flux-balance-analysis/">Flux balance analysis (FBA)</a></li><li><a class="tocitem" href="../../examples/02a-optimizer-parameters/">Changing optimizer parameters</a></li><li><a class="tocitem" href="../../examples/02b-model-modifications/">Making adjustments to the model</a></li><li><a class="tocitem" href="../../examples/02c-constraint-modifications/">Making adjustments to the constraint system</a></li><li><a class="tocitem" href="../../examples/03-parsimonious-flux-balance/">Parsimonious flux balance analysis</a></li><li><a class="tocitem" href="../../examples/04-minimization-of-metabolic-adjustment/">Minimization of metabolic adjustment analysis</a></li><li><a class="tocitem" href="../../examples/05-enzyme-constrained-models/">Enzyme constrained models</a></li><li><a class="tocitem" href="../../examples/06-mmdf/">Thermodynamic models</a></li><li><a class="tocitem" href="../../examples/07-loopless-models/">Loopless flux balance analysis (ll-FBA)</a></li><li><a class="tocitem" href="../../examples/08-community-models/">Community FBA models</a></li></ul></li><li><span class="tocitem">Parallel, distributed and HPC processing</span><ul><li><a class="tocitem" href="../../distributed/">Contents</a></li><li><a class="tocitem" href="../../distributed/1_functions/">Parallel processing overview</a></li><li><a class="tocitem" href="../../distributed/2_parallel/">Local parallel processing</a></li><li><a class="tocitem" href="../../distributed/3_slurm/">Working in a HPC environment</a></li></ul></li><li><span class="tocitem">Core concepts guide</span><ul><li><a class="tocitem" href="../">Contents</a></li><li class="is-active"><a class="tocitem" href>Screening many model variants</a><ul class="internal"><li><a class="tocitem" href="#Variant-specification"><span>Variant specification</span></a></li><li><a class="tocitem" href="#Writing-custom-variant-functions"><span>Writing custom variant functions</span></a></li><li><a class="tocitem" href="#Passing-extra-arguments-to-the-analysis-function"><span>Passing extra arguments to the analysis function</span></a></li></ul></li></ul></li><li><span class="tocitem">API reference</span><ul><li><a class="tocitem" href="../../reference/">Contents</a></li><li><a class="tocitem" href="../../reference/analysis/">Specialized analysis functions</a></li><li><a class="tocitem" href="../../reference/builders/">Constraint system builders</a></li><li><a class="tocitem" href="../../reference/core/">Core functionality</a></li><li><a class="tocitem" href="../../reference/frontend/">Front-end user interface</a></li><li><a class="tocitem" href="../../reference/misc/">Miscellaneous functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Core concepts guide</a></li><li class="is-active"><a href>Screening many model variants</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Screening many model variants</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/COBREXA/COBREXA.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/COBREXA/COBREXA.jl/blob/master/docs/src/concepts/1_screen.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Screening-many-model-variants"><a class="docs-heading-anchor" href="#Screening-many-model-variants">Screening many model variants</a><a id="Screening-many-model-variants-1"></a><a class="docs-heading-anchor-permalink" href="#Screening-many-model-variants" title="Permalink"></a></h1><p>A major goal of COBREXA.jl is to make exploring of many model variants easy and fast.</p><p>One main concept that can be utilized for doing that is implemented in the function <code>screen</code>, which takes your model, a list of model <em>variants</em> that you want to explore by some specified <em>analysis</em>, and schedules the analysis of the model variants parallelly on the available distributed workers.</p><p>In its most basic form, the &quot;screening&quot; may use the slightly simplified variant of <code>screen</code> that is called <code>screen_variants</code>, which works as follows:</p><pre><code class="language-julia hljs">m = load_model(ObjectModel, &quot;e_coli_core.json&quot;)

screen_variants(
    m,    # the model for screening
    [
        [],    # a variant with no modifications
        [with_changed_bound(&quot;CO2t&quot;, lb = 0, ub = 0)],  # disable CO2 transport
        [with_changed_bound(&quot;O2t&quot;, lb = 0, ub = 0)],  # disable O2 transport
        [with_changed_bound(&quot;CO2t&quot;, lb = 0, ub = 0), with_changed_bound(&quot;O2t&quot;, lb = 0, ub = 0)],  # disable both transports
    ],
    m -&gt; flux_balance_dict(m, Tulip.Optimizer)[&quot;BIOMASS_Ecoli_core_w_GAM&quot;],
)</code></pre><p>The call specifies a model (the <code>m</code> that we have loaded) that is being tested, then a vector of model variants to be created and tested, and then the analysis that is being run on each variant – in this case, we find an optimal steady state of each of the variants, and check out the biomass production rate at that state. In this particular case, we are checking what will be the effect of disabling combinations of CO2 transport and O2 transport in the cells. For that, we get the following result:</p><pre><code class="nohighlight hljs">4-element Vector{Float64}:
 0.8739215022678488
 0.46166961413944896
 0.21166294973372135
 0.21114065173865518</code></pre><p>The numbers are the biomass production rates for the specified variants. We can see that disabling O2 transport really does not help the organism much.</p><h2 id="Variant-specification"><a class="docs-heading-anchor" href="#Variant-specification">Variant specification</a><a id="Variant-specification-1"></a><a class="docs-heading-anchor-permalink" href="#Variant-specification" title="Permalink"></a></h2><p>In the above example, we have specified 4 variants, thus the analysis returned 4 different results that correspond with the specifications. Let us have a look at the precise format of the specification and result.</p><p>Importantly, the <code>variants</code> argument is of type <code>Array{Vector{Any}}</code>, meaning that it can be an array of any dimensionality that contains vectors. Each of the vectors specifies precisely one variant, possibly with more modifications applied to the model in sequence.</p><p>For example:</p><ul><li><code>[]</code> specifies no modifications at all</li><li><code>[with_changed_bound(&quot;CO2t&quot;, lb=0, ub=10)]</code> limits the CO2 transport</li><li><code>[with_changed_bound(&quot;CO2t&quot;, lb=0, ub=2), with_changed_bound(&quot;O2t&quot;, lb=0, ub=100)]</code> severely limits the CO2 transport <em>and</em> slightly restricts the transport of O2</li></ul><div class="admonition is-info"><header class="admonition-header">Variants are single-parameter model-transforming functions</header><div class="admonition-body"><p>Because the variants are just generators of single parameter functions that take the model and return its modified version, you can also use <code>identity</code> to specify a variant that does nothing – <code>[identity]</code> is perfectly same as <code>[]</code></p></div></div><p>The shape of the variants array is important too, because it is precisely retained in the result (just as with <code>pmap</code>). If you pass in a matrix of variants, you will receive a matrix of analysis results of the same size. That can be exploited for easily exploring many combinations of possible model properties. Let&#39;s try exploring a &quot;cube&quot; of possible restricted reactions:</p><pre><code class="language-julia hljs">using IterTools # for cartesian products

res = screen_variants(m,
    [
        # for each variant we restricts 2 reactions
        [with_changed_bound(r1, lb=-3, ub=3), with_changed_bound(r2, lb=-1, ub=1)]

        # the reaction pair will be chosen from a cartesian product
        for (r1,r2) in product(
            [&quot;H2Ot&quot;, &quot;CO2t&quot;, &quot;O2t&quot;, &quot;NH4t&quot;], # of this set of transport reactions
            [&quot;EX_h2o_e&quot;, &quot;EX_co2_e&quot;, &quot;EX_o2_e&quot;, &quot;EX_nh4_e&quot;], # and this set of exchanges
        )
    ],
    m -&gt; flux_balance_dict(m, Tulip.Optimizer)[&quot;BIOMASS_Ecoli_core_w_GAM&quot;],
)</code></pre><p>As a result, we will receive a full matrix of the biomass productions:</p><pre><code class="nohighlight hljs">4×4 Matrix{Float64}:
 0.407666  0.454097  0.240106  0.183392
 0.407666  0.485204  0.24766   0.183392
 0.314923  0.319654  0.24766   0.183392
 0.407666  0.485204  0.24766   0.183392</code></pre><p>Notably, this shows that O2 transport and NH4 exchange may be serious bottlenecks for biomass production.</p><p>For clarity, you may always annotate the result by zipping it with the specification structure you have used and collecting the data:</p><pre><code class="language-julia hljs">collect(zip(
    product(
        [&quot;H2Ot&quot;, &quot;CO2t&quot;, &quot;O2t&quot;, &quot;NH4t&quot;],
        [&quot;EX_h2o_e&quot;, &quot;EX_co2_e&quot;, &quot;EX_o2_e&quot;, &quot;EX_nh4_e&quot;],
    ),
    res,
))</code></pre><p>...which gives the following annotated result:</p><pre><code class="nohighlight hljs">4×4 Matrix{Tuple{Tuple{String, String}, Float64}}:
 ((&quot;H2Ot&quot;, &quot;EX_h2o_e&quot;), 0.407666)  ((&quot;H2Ot&quot;, &quot;EX_co2_e&quot;), 0.454097)  ((&quot;H2Ot&quot;, &quot;EX_o2_e&quot;), 0.240106)  ((&quot;H2Ot&quot;, &quot;EX_nh4_e&quot;), 0.183392)
 ((&quot;CO2t&quot;, &quot;EX_h2o_e&quot;), 0.407666)  ((&quot;CO2t&quot;, &quot;EX_co2_e&quot;), 0.485204)  ((&quot;CO2t&quot;, &quot;EX_o2_e&quot;), 0.24766)   ((&quot;CO2t&quot;, &quot;EX_nh4_e&quot;), 0.183392)
 ((&quot;O2t&quot;, &quot;EX_h2o_e&quot;), 0.314923)   ((&quot;O2t&quot;, &quot;EX_co2_e&quot;), 0.319654)   ((&quot;O2t&quot;, &quot;EX_o2_e&quot;), 0.24766)    ((&quot;O2t&quot;, &quot;EX_nh4_e&quot;), 0.183392)
 ((&quot;NH4t&quot;, &quot;EX_h2o_e&quot;), 0.407666)  ((&quot;NH4t&quot;, &quot;EX_co2_e&quot;), 0.485204)  ((&quot;NH4t&quot;, &quot;EX_o2_e&quot;), 0.24766)   ((&quot;NH4t&quot;, &quot;EX_nh4_e&quot;), 0.183392)</code></pre><p>This may be easily used for e.g. scrutinizing all possible reaction pairs, to find the ones that are redundant and not.</p><p>There are many other variant &quot;specifications&quot; to choose from. You may use <code>with_added_reactions</code>, <code>with_removed_reactions</code>, <code>with_removed_metabolites</code>, and others. Function reference contains a complete list; as a convention, names of the specifications all start with <code>with_</code>.</p><h2 id="Writing-custom-variant-functions"><a class="docs-heading-anchor" href="#Writing-custom-variant-functions">Writing custom variant functions</a><a id="Writing-custom-variant-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-custom-variant-functions" title="Permalink"></a></h2><p>It is actually very easy to create custom specifications that do any modification that you can implement, to be later used with <code>screen_variants</code> and <code>screen</code>.</p><p>Generally, the &quot;specifications&quot; are supposed to return a <em>function</em> that creates a modified copy of the model. The copy of the model may be shallow, but the functions should always prevent modifying the original model structure – <code>screen</code> is keeping a single copy of the original model at each worker to prevent unnecessary bulk data transport, and if that is changed in-place, all following analyses of the model will work on inconsistent data, usually returning wrong results (even randomly changing ones, because of the asynchronous nature of <code>screen</code> execution).</p><p>Despite of that, writing a modification is easy. The simplest modification that &quot;does nothing&quot; (isomorphic to standard <code>identity</code>) can be formatted as follows:</p><pre><code class="language-julia hljs">with_no_change = model -&gt; model</code></pre><p>The modifications may change the model, provided it is copied properly. The following modification will remove a reaction called &quot;O2t&quot;, effectively removing the possibility to transport oxygen. We require a specific type of model where this change is easy to perform (generally, not all variants may be feasible on all model types).</p><pre><code class="language-julia hljs">with_disabled_oxygen_transport = (model::ObjectModel) -&gt; begin

    # make &quot;as shallow as possible&quot; copy of the `model`.
    # Utilizing `deepcopy` is also possible, but inefficient.
    new_model = copy(model)
    new_model.reactions = copy(model.reactions)

    # remove the O2 transport from the model copy
    delete!(new_model.reactions, &quot;O2t&quot;)

    return new_model #return the newly created variant
end</code></pre><p>Finally, the whole definition may be parameterized as a normal function. The following variant removes any user-selected reaction:</p><pre><code class="language-julia hljs">with_disabled_reaction(reaction_id) = (model::ObjectModel) -&gt; begin
    new_model = copy(model)
    new_model.reactions = copy(model.reactions)
    delete!(new_model.reactions, reaction_id) # use the parameter from the specification
    return new_model
end</code></pre><p>In turn, these variants can be used in <code>screen_variants</code> just as we used <code>with_changed_bound</code> above:</p><pre><code class="language-julia hljs">screen_variants(
    m,    # the model for screening
    [
        [with_no_change],
        [with_disabled_oxygen_transport],
        [with_disabled_reaction(&quot;NH4t&quot;)],
    ],
    m -&gt; flux_balance_dict(m, Tulip.Optimizer)[&quot;BIOMASS_Ecoli_core_w_GAM&quot;],
)</code></pre><p>That should get you the results for all new variants of the model:</p><pre><code class="nohighlight hljs">3-element Vector{Float64}:
 0.8739215022674809
 0.21166294865468896
 1.2907224478973395e-15</code></pre><div class="admonition is-warning"><header class="admonition-header">Custom variants with distributed processing</header><div class="admonition-body"><p>If using distributed evaluation, remember the variant-generating functions need to be defined on all used workers (generating the variants in parallel on the workers allows COBREXA to run the screening process very efficiently, without unnecessary sending of bulk model data). Prefixing the definition with <code>@everywhere</code> is usually sufficient for that purpose.</p></div></div><h2 id="Passing-extra-arguments-to-the-analysis-function"><a class="docs-heading-anchor" href="#Passing-extra-arguments-to-the-analysis-function">Passing extra arguments to the analysis function</a><a id="Passing-extra-arguments-to-the-analysis-function-1"></a><a class="docs-heading-anchor-permalink" href="#Passing-extra-arguments-to-the-analysis-function" title="Permalink"></a></h2><p>Some analysis functions may take additional arguments, which you might want to vary for the analysis. <code>modifications</code> argument of <code>flux_balance_dict</code> is one example of such argument, allowing you to specify details of the optimization procedure.</p><p><code>screen</code> function allows you to do precisely that – apart from <code>variants</code>, you may also specify an array of <code>args</code> of the same shape as <code>variants</code>, the entries of which will get passed together with the generated model variants to your specified analysis function. If either of the arguments is missing (or set to <code>nothing</code>), it is defaulted to &quot;no modifications&quot; or &quot;no arguments&quot;.</p><p>The arguments <em>must</em> be tuples; you may need to make 1-tuples from your data (e.g. using <code>(value,)</code>) if you want to pass just a single argument.</p><p>Let&#39;s try to use that functionality for trying to find a sufficient amount of iterations needed for Tulip solver to find a feasible solution:</p><pre><code class="language-julia hljs">screen(m,
    args = [(i,) for i in 5:15],  # the iteration counts, packed in 1-tuples
    analysis = (m,a) -&gt; # `args` elements get passed as the extra parameter here
        flux_balance_vec(m,
            Tulip.Optimizer;
            modifications=[modify_optimizer_attribute(&quot;IPM_IterationsLimit&quot;, a)],
        ),
)</code></pre><p>From the result, we can see that Tulip would need at least 14 iterations to find a feasible region:</p><pre><code class="nohighlight hljs">11-element Vector{Union{Nothing, Vector{Float64}}}:
 nothing
 nothing
 nothing
 nothing
 nothing
 nothing
 nothing
 nothing
 nothing
 [7.47738193404817, 1.8840414375838503e-8, 4.860861010127701, -16.023526104614593, … ]
 [7.47738193404817, 1.8840414375838503e-8, 4.860861010127701, -16.023526104614593, … ]</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Contents</a><a class="docs-footer-nextpage" href="../../reference/">Contents »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Friday 2 February 2024 09:11">Friday 2 February 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
